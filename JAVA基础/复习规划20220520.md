# 复习规划
## 1.JAVA基础
### 1.1、JAVA基本数据类型
答：分四类，公8种。
1. 整型：byte(1),short(2),int（4），Long(8);
2. 浮点型：float(4),double(8);
3. 布尔型：boolean：true,false;
4. 字符型：char(2)
### 1.2、Java类和对象的概念
JAVA是面向对象的编程语言，类是对象的抽象表示，对象是类的实例。
#### 1.2.1、类与类之间的关系
关联、聚合、组合、依赖、继承、实现
### 1.3、Java面向对象的三个特征？
封装、继承、多态。
#### 1.3.1、封装
通过访问修饰符public、缺省、project、private来实现。可以限制性的访问类和对象的方法、属性。
#### 1.3.2、继承
子类可以继承父类所有的东西，但是子类看不到父类private的属性和方法。
#### 1.3.3、多态
将子类的引用赋值给一个父类对象，这样子类可以重写父类的方法，也可以扩展拥有自己的属性和方法。
#### 1.3.4、面向对象编程（OOP）
面向对象编程将现实世界中的概念和事务，以及相应的状态和行为，抽象成计算机语言中的类和对象，以及相应的属性和方法，这是一个抽象的过程。类和对象是面向对象编程的核心概念，它包含有封装、继承、多态三大特征，也有人把抽象作为它的第四大特征。由于面向对象的使用，使得程序的可扩展性大大增强，面向对象编程在大型项目中得到了广泛的使用。面向对象的思想更符合于我们人类对现实世界的认知，可以使我们设计出更加灵活，维护性更好的程序。
### 1.4、抽象方法、抽象类、接口
#### 1.4.1、抽象方法、抽象类
抽象方法、抽象类通过abstract关键字修饰。
含有抽象方法的类必须是抽象类，因为如果某个拥有抽象方法的类被其子类继承，并去掉这个父类的抽象方法，而抽象方法是没有方法体的，这时候应该输出什么呢？
答：编译器肯定会报错，所以这个时候就只能将这个父类也声名为抽象类，这样其子类就必须去重写它的抽象方法，这样就这个问题就解决了。当然如果这个子类不需要重写这个抽象方法，那也可以将自己也定义为抽象类即可。
一个类只能继承一个父类，即单继承。
#### 1.4.2、接口
通过interface关键字修饰。接口里面有常量和抽象方法，就是通过实现该接口的类去重写抽象方法，从而实现多态。
一个类可以实现多个接口。
万事万物皆对象，面向对象编程，面向接口编程。
JDK8以后，接口里面可以有静态方法（static）和默认方法（default）。  
### 1.5、封箱和拆箱
### 1.6、异常处理
#### 1.6.1、 JAVA处理异常的思路：
一是自己捕获处理，即加try(){}catch(){};
二是处理以后再向上抛出；
三是直接向上抛出(throw e)异常,对应的方法上也要加上throws e，甚至可以将异常抛给main方法，最终交由JVM去处理，当然不推荐这样做。
#### 1.6.2、JAVA程序的错误：
1. 代码错误，一般编译器就会帮我们指出。
2. 逻辑错误，需要测试，才能排查出来。
3. 程序运行期发生的错误。这种错误也分三种，一种是error，比如内存溢出等，这种不用出来，JVM会报错，直接终止程序；第二种是运行时异常（RuntimeException），也叫非受检查异常，也不用处理，JVM会处理，打出堆栈错误，终止程序等等；第三种是除前两种意外的异常（空指针等），也叫受检查异常或非运行时异常，需要我们去处理，必须捕获处理，或向上抛出。
4. 自定义异常
#### 1.6.3、therow和throws的区别？
throw用于在方法内部抛出异常，throws用于方法之上，两者一般是成对出现。
### 1.7、IO流
### 1.8、集合
JAVA中的集合又称容器，是对数据结构的一种实现，通过集合，我们可以完成对数据的增删改查，方便程序员管理数据。
JAVA中集合中的数据是存储在内存当中的，是一种临时的数据存储方式，当服务器重启或出现故障的情况下，集合中的数据就会消失。
#### 1.8.1、JAVA集合体系
![JAVA集合体系](vx_images/168244017220562.png =998x)
#### 1.8.2、Collection接口
1. List和Set集合的父接口，当然还有其它的实现类或子接口。
#### 1.8.3、List接口
Collection接口的子接口，存储有序，可重复的数据。
#### 1.8.4、ArrayList
数据结构：数组，相对于链表，查询快，增删慢。
常用方法：
```
 List<String> arrayList=new ArrayList<>();
        arrayList.add("尾");//尾加
        arrayList.add(1,"一");//插入
        arrayList.add(1,"二");//插入一个新值，原先在这个位置上的将往后移一位
        arrayList.set(1,"3");//覆盖掉原先在这个位置上的值
        arrayList.remove(0);
        arrayList.remove("一");
        //遍历方式：1、for循环、2、增强for、3、迭代器iterator
        Iterator<String> iterator = arrayList.iterator();
        while (iterator.hasNext()){
            System.out.println(iterator.next().toString());
        }
```
扩容机制：1.5N,生成一个新的数组，将原来的数组复制到新的数组中。删除同理。

`
//默认长度10
private static final int DEFAULT_CAPACITY = 10;
`

不足点：线程不安全，方法无synchronized修饰等。与之对应的Vector是线程安全的。
#### 1.8.5、LinedkList
数据结构：双向非循环链表，相对于数组，增删快，查询慢。
常用方法：
```
LinkedList<String> linkedList=new LinkedList<>();
        linkedList.add("一");
        linkedList.add("二");
        linkedList.addLast("tail");
        linkedList.addFirst("head");
        System.out.println(linkedList.toString());//[head, 一, 二, tail]
        linkedList.remove("一");
        System.out.println(linkedList.toString());//[head, 二, tail]
```
不足点：线程不安全，方法无synchronized修饰等。
#### 1.8.6、Set
Set继承了Collection接口，里面没有额外的方法。
实现无序（这里的无序是指和元素的添加顺序不一致而已，其实里面有排序规则），不可重复的数据集合。
#### 1.8.7、HashSet
数据结构：基于HashMap实现。
特点：存储无序，不可重复的数据。没有根据索引操作数据的方法。
常用方法：
```
Set<String> hashSet=new HashSet<>();
        hashSet.add("a");
        hashSet.add("b");
        hashSet.add("c");
        hashSet.add("a");//有重复则覆盖
        hashSet.remove("c");
        for (String s:hashSet
             ) {
            System.out.println(s.toString());
        }
```
#### 1.8.10、TreeSet
数据结构：基于TreeMap实现。
常用方法：
```
TreeSet<String> treeSet= new TreeSet<>();
       treeSet.add("a");
       treeSet.add("b");
       treeSet.add("c");
       treeSet.add("a");//覆盖掉相同的值
       treeSet.remove("c");
        for (String s:treeSet
             ) {
            System.out.println(s.toString());
        }
```
#### 1.8.11、Map接口
Map接口是独立的接口，和Collection没关系。
Map中的每一个元素都是一个entry类型，每个元素包含key(键)和value(值)。
Map存储无序（指和添加元素时的顺序不一致），不可重复的元素。
#### 1.8.12、HashMap
HashMap是对散列表的具体实现。
数据结构：数组+链表。
```
Map<String,Object> hashMap=new HashMap<>();
        hashMap.put("1","张三");
        hashMap.put("2","张三");
        hashMap.put("3","李四");
        hashMap.put("3","李四四");//key相同则覆盖掉原来的值
        hashMap.put(null,null);//只允许一个key为null
        hashMap.put("4",null);//可允许多个value为null
        //遍历：
        //keySet遍历：
        for (String key:
                hashMap.keySet()) {
            System.out.println(key);
        }
        //entry遍历
        for (Map.Entry<String,Object> entry:
             hashMap.entrySet()) {
            System.out.println("key:"+entry.getKey().toString()+";"+"value:"+entry.getValue());
        }
```
不足：线程不安全。
特点：只允许一个key为null,多个value为null，但遍历取值的时候有可能报空指针异常。
#### 1.8.13、TreeMap
数据结构：红黑树。
特点：和HashMap类似，不允许key为null。
常用方法：
```
Map<String,Integer> treeMap=new TreeMap<>();
        treeMap.put("张三",20);
        treeMap.put("李四",30);
        treeMap.put("王麻子",40);
        treeMap.put("王麻子",43);//key重复，则覆盖掉原来的value
        treeMap.put(null,43);//不允许key为null的情况,若为key为空，则会报空指针的错误
        treeMap.remove("李四");
        //遍历 1、keySet()
        for (String key:treeMap.keySet()) {
            System.out.println(key);
        }
        //遍历 2、entrySet() 遍历
        for (Map.Entry<String,Integer> entry:treeMap.entrySet()) {
            System.out.println(entry.getKey()+":"+entry.getValue());
        }
```
#### 1.8.14、Iterator
迭代器，是一个接口，每一个集合的实现类的内部基本都有对Iterator的实现，通过Iterator可以实现对集合的遍历。
存在的意义：隐藏集合内部的实现细节，无论那种集合都是通过Iterator操作，而不是直接操作该集合。
实例化：每个集合都有.iterator()方法，该方法的返回值就是一个迭代器对象。
示例：
```
 List<String> arrayList=new ArrayList<>();
        arrayList.add("尾");//尾加
        arrayList.add(1,"一");//插入
        arrayList.add(1,"二");//插入一个新值，原先在这个位置上的将往后移一位
        arrayList.set(1,"3");//覆盖掉原先在这个位置上的值
        arrayList.remove(0);
        arrayList.remove("一");
        //遍历方式：1、for循环、2、增强for、3、迭代器iterator
        Iterator<String> iterator = arrayList.iterator();
        while (iterator.hasNext()){
            System.out.println(iterator.next().toString());
            iterator.remove();//删除当前值
        }
```
#### 1.8.15、Collections
Collections是一个工具类型，一个专门操作集合的工具类
常用方法：
```
List<Integer> arrayList=new ArrayList<>();
      arrayList.add(5);
      arrayList.add(3);
      arrayList.add(1);
      arrayList.add(2);
      arrayList.add(4);
      System.out.println(arrayList.toString());//[5, 3, 1, 2, 4]
      Collections.sort(arrayList);//排序
      System.out.println(arrayList.toString());//[1, 2, 3, 4, 5]
       //添加多个值到集合当中
        Collections.addAll(arrayList,7,8,9,67,68,69);
        System.out.println(arrayList.toString());//[1, 2, 3, 4, 5, 7, 8, 9, 67, 68, 69]
        //取最大值，最小值
        Integer max = Collections.max(arrayList);
        System.out.println(max);//69
        Integer min = Collections.min(arrayList);
        System.out.println(min);//1
```
### 1.9、泛型(Generics)
1. JDK1.5引入。
2. 参数化类型。即”先泛泛定义要使用的一个类型，使用的时候再具体指定这个类型“。
3. 在定义类、接口或方法的时候，使用<类型参数>来声名，也称参数化类型，泛型。类型参数将被使用在类、接口或方法的定义中，比如属性定义，方法参数，返回值；在今后具体使用这个类或方法的时候，用具体的一个类型来替代类型参数，作为类型实参。
4. 使用了泛型的类、接口、方法，简称为泛型类、泛型接口、泛型方法。
5. 集合框架里面使用了泛型，这样可以在使用集合的时候，再具体指定使用的元素类型；泛型给集合元素提供了类型检查功能。注意，数组有天然的类型检查功能。
`public class GenericsTest {

    public static void main(String[] args){

       /* Cat<String> cat = new Cat<String>();
        cat.setT("大貓");
        cat.say();*/

        Cat<Integer> cat = new Cat<Integer>(3);
        cat.setT(3);
        cat.say();
    }
}

class Cat<T>{
    T t;

    public T getT(){
        return t;
    }

    public Cat(T t){
        this.t=t;
    }
    public void setT(T t){
        this.t=t;
    }
    public void say(){
        System.out.println(t);
    }
}`
#### 1.9.1、泛型类
1. <>里可以声名多个类型参数，用逗号隔开，比如HashMap。
2. 泛型类在声名构造器的时候直接使用类名，不能加<>,比如：Cat(){}
3. 泛型实参可以是类，数组；基本数据类型不能用于泛型的实参，需要使用包装类。
4. 静态方法不能使用类的泛型。
5. 泛型类作为父类，可以是实参化，则子类不再声名此泛型，不再是泛型类；如果不实参化，则子类需要声明此泛型，依然是泛型类。

`public class GenericsTest {

    public static void main(String[] args){

        Cat<String>  cat = new Cat<>();
    }
}

abstract class PCat<T>{
   T t;
}

class Cat<T> extends PCat<T>{

}`
6. 泛型接口被实现的时候，可以实参化，则实现类不用再声明此泛型，不再是泛型类；如果不实参化，则实现类需要声明此泛型，依然是泛型类。

`public class GenericsTest {

    public static void main(String[] args){

        Cat<String,String>  cat = new Cat<>();
    }
}

interface ICat<T>{
    void eat();
}

abstract class PCat<T>{
   T t;
}

class Cat<T,I> extends PCat<T> implements ICat<I>{

    @Override
    public void eat() {

    }
}`
7. 泛型可以嵌套。
8. 泛型类相同，实参类型不一样的对象不能相互赋值。
9. 创建泛型的数组不能new T[10],可以写为(T[])new Object[10]。
10. 从JDK1.7开始，在创建泛型类对象的时候，可以使用类型推断，省略泛型实参，比如：new Cat<>();
11. 定义了泛型，就应该使用泛型；创建泛型类对象时，如果不使用泛型，则将这个类称为原始类型（raw type），应该避免使用原始类型。
12. 异常类不能定义为泛型类。
#### 1.9.2、泛型方法
1. 用<类型参数>放在方法的返回值前来声明泛型方法。
2. 声明的泛型可以用在方法参数，返回值，以及方法内部。
3. 泛型方法可以是静态方法也可以是非静态方法。
4. 泛型方法可以在泛型类中，也可以在普通类中。如果放在泛型类里，声明的泛型符号尽量和泛型类的泛型符号不同。
5. 注意区分，泛型方法和泛型类使用了类的泛型的方法。
##### 1.9.1.2、为何要使用泛型
1. 强制类型检查。
2. 帮助完成了强制类型转换。
3. 健壮性、可读性增强。
##### 1.9.1.3、类型擦除
1. 泛型只存在于编译期中，泛型只会在编译期使用，然后被擦除，Java不会保留泛型，到运行时并没有泛型。
2. 编译期内部永远把所有类型T视为Object处理，但是，在需要转型的时候，编译期会根据T的类型自动实行安全的强制转型。也就是说，编译器执行类型检查的类型推断，然后在生成字节码之前将泛型清除掉。
3. 类型擦除是Java特有的，是历史遗留的妥协问题，是为了和JDK1.5以前没有泛型的类库兼容。
4. 泛型被擦除，则泛型会被转译成Object类型，如果指定了上限则转译成上限，如：<T extends String>则泛型就被替换成String。
5. 类型擦除，使得泛型能够与之前的JDK版本代码兼容，但却抹掉了泛型、泛型之间的特征，这是它带来的问题。
### 1.10、枚举类
1. 使用enum声名，是一种受限制的类。
2. 枚举类用于定义，列举一组同一种类型的常量，这些常量也可以称为枚举值，枚举成员，枚举实例。枚举成员用常量的方式命名。
3. 枚举成员是有顺序的，序号从0开始。
4. 枚举类的父类为java.lang.Enum。
5. 可以添加属性，方法，private或者”无“的构造器。
6. 因为枚举类已经有父类，所以不能再继承自其他类，但是可以实现接口。
7. 每个枚举成员，可以看做枚举类的常量，在外部使用中代表枚举值。
8. 每个枚举成员，可以看做枚举类的子类，可以构造器传参，可以定义自己的属性，甚至可以重写枚举类的方法。
9. Thread.State为枚举类，java8中新增了DayOfWeek,Month枚举类。
#### 1.10.1、Enum类的方法
values(),valuesOf(),toString(),ordinal(),compareTo(),equals()

```
public class EnumTest {

    public static void main(String[] args){
       Day myDay=Day.TODAY;

       switch (myDay){
           case TODAY:
               System.out.println(Day.TODAY);
               break;
           case TOMORROW:
               System.out.println(Day.TOMORROW);
               break;
           case YESTERDAY:
               System.out.println(Day.YESTERDAY);
               break;
       }
    }

    static enum Day{
        YESTERDAY,TODAY,TOMORROW
    }
}

```
### 1.11、IO流

## 2、主流框架
### 2.1、SpringMVC
#### 2.1.1、Aop和IOC(DC)
#### 2.1.2、常用组件
#### 2.1.3、执行流程
#### 2.1.4、拦截器和过滤器的区别
### 2.2、SpringBoot
#### 2.2.1、执行原理
#### 2.2.2、常见注解
@Resource和@Autowired异同
### 2.3、持久层框架
#### 2.3.1、MyBaits
##### 2.3.1.1、执行原理
##### 2.3.1.2、#和$的区别
## 3、数据库
### 3.1、MySQL
#### 3.1.1、三大范式
#### 3.1.2、事务与ACID
#### 3.1.3、索引
1. 索引失效
2. 索引类型
#### 3.1.4、存储引擎
#### 3.1.5、JDBC驱动执行顺序（MyBatis执行原理）
#### 3.1.6、SQL执行顺序
from、on、join、where、group by  having、select、distinct、union、order by
#### 3.1.7、常见聚合函数
### 3.2、Oracle
#### 3.2.1、函数、存储过程、视图
## 4、JAVA高级
### 4.1、多线程
#### 4.1.1、并行与并发
并行：指多个任务同时进行，强调的是各个任务之间的独立性和实时性。计算机中指多个处理器同时执行多个任务。
并发：在一个系统内，当资源有限的情况下，通过并发设计，达到部分并行的效果。计算机中指一个处理器，按一定的设计，尽可能达到同时处理多个任务的效果。
#### 4.1.2、进程与线程
进程：
1. 一个正在进行的程序。一个进程中可以使用多个线程来实现并发设计，从而达到并行的效果。
2. 一个进程有自己的内存资源。
3. 一个进程有自己的生命周期，包括创建、生存、消亡等。
线程：
1. 进程的基本单位。在JAVA程序中，程序从一个主线程（main线程）开始，主线程可以创建其他的线程。
2. 线程也有自己的生命周期。创建、生存、消亡等。
3. 线程是进程的一个组件，一个进程中的多个线程可以共享这个进程的内存等资源。
#### 4.1.3、Java程序、JVM实例、用户线程（User Thread）、守护线程(Daemon Thread)
1. 以JAVA命令启动的JAVA程序，都会新增一个JVM实例。一旦程序结束，JVM实例也就销毁了。每个程序都会获得自己的JVM实例和对应的OS级进程，并且每个JVM实例相互独立。
2. 每个JAVA程序运行在单独JVM实例上，每一个JVM实例对应唯一的一个堆，所以一个JAVA程序中的多个线程也就运行同一个JVM实例之上，因此这些线程之间会共享这块堆内存，鉴于此，多线程在访问堆中数据时需要进行线程同步。
3. 守护线程是为其他的线程提供便利服务的，当用户线程结束时，守护线程也就没有存在的意义了，也会销毁。
4. mian线程就是一个用户线程，GC(垃圾回收器)就是一个守护向线程。GC随主线程从开始到结束。
#### 4.1.4、JAVA中创建线程
`public class Test {
    public static void main(String[] args) throws Exception {
    
        //1、继承Thread类，重写run()方法，在run()方法里面写具体的逻辑。
        //注意用对象调用的时候是调start()方法启动线程，线程启动之后JVM会自动去再掉run()方法。
        //永远不要启动一个线程超过一次，即使这个线程启动完毕，也不要再启动该线程。
        //Thread类里面的run()方法只是一个方法，不能用于启动线程。源码中有标注。
        MyThread myThread=new MyThread();
        myThread.start();
        
        //2、实现Runnable接口，重写run()方法，在run()方法里面写具体的逻辑。还是通过start()方法启动线程。
         Thread runnableThread = new Thread(new MyRunnable());
         runnableThread.start();
         
        //还可以直接写成匿名内部类的方式：
         Thread thread = new Thread(new Runnable() {
            @Override
            public void run() {
                for(int i=0;i<50;i++){
                    System.out.println(Thread.currentThread().getName()+":"+i);
                }

            }
        });
        thread.start();
        
        //3、实现Callable<T>接口，重写call()方法，在call()方法里面写具体的逻辑。
        //特点：有返回值，返回值的类型就是实现该接口时传进去的泛型T。
        FutureTask<String> futureTask=new FutureTask<String>(new MyCallable1());
            Thread thread=new Thread(futureTask);
            thread.start();
            try {
                System.out.println("main线程调用get()");
                if(futureTask.isDone()){
                    String s = futureTask.get();
                    System.out.println(s);
                }else {
                    System.out.println("main:先干其他的事情了");
                    Thread.sleep(2000);
                    String s = futureTask.get();
                    System.out.println(s);
                }
            } catch (InterruptedException |ExecutionException e) {
                e.printStackTrace();
            }
        }
    }
}

class MyThread extends Thread{

    @Override
    public void run() {
        for(int i=0;i<100;i++){
            System.out.println("MyThread："+i);
        }
    }
}

class MyRunnable implements Runnable{

    @Override
    public void run() {
        for(int i=0;i<100;i++){
            System.out.println("MyRunAble："+i);
        }
    }
}

class MyCallable1 implements Callable<String>{

    @Override
    public String call(){
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("线程就绪并已经启动了");
        return "from MyCallable1";
    }
}
`
使用Callable<V>接口创建子线程
1. Runnable接口无返回值，也无法抛出异常，所以就设计了Callable接口
* Callable接口规定的方法是V call(),而Runnable接口的方法是run()。
* V call()方法可抛出异常，而run()方法不能抛出异常。
* V call()方法有返回值，而run()方法无返回值。
* Callable接口配合FutureTask对象一起，创建子线程，执行V call()方法，并取得执行结果。
2. 实现原理
* 实现Callable<V>接口，在其V call()方法里面写需要子线程执行的代码，并将返回值以V类型返回。
* Future接口提供了V get()方法，用于得到返回值。
* FutureTask类实现了RunnableFuture接口，这个接口继承自两个接口：Runnable和Future。在创建FutureTask对象的时候，可以把Callable接口的实现对象传入。这样FutureTask对象因为实现了Runnable接口，可以用于创建子线程，因为有了Callable接口的实现对象的引用，可以调用回调方法V call(),得到返回值V，因为其实现了Future接口，可以通过V get()方法提供返回值给外部。
* 这是一种异步回调V call()方法的方式。
##### 4.1.4.1、线程中常用的方法
1. isAlive()判断线程是否存活
2. Thread.sleep(1000)静态方法，让当前线程休眠一段时间，处于阻塞状态。
3. Thread.currentThread().getName()得到当前线程的名字。
4. hread.yield();//静态方法，让出一次当前CPU的使用权,若让出之后其他线程抢不到，那还可以抢回来
示例代码：

`public class TestThread {
    public static void main(String[] args) throws InterruptedException {

        MyThread myThread1 = new MyThread("我的线程");
        myThread1.start();

        System.out.println(myThread1.isAlive());//isAlive()判断线程是否存活
        for(int i=0;i<100;i++){
            Thread.sleep(1000);//静态方法，让当前线程休眠一段时间，处于阻塞状态
            System.out.println(Thread.currentThread().getName()+":"+i);
        }

        System.out.println(myThread1.isAlive());
    }

    public static class MyThread extends Thread{

        public MyThread(String name) {
            super(name);
        }

        @Override
        public void run() {
           for(int i=0;i<100;i++){
               try {
                   if(i%10==0){
                       Thread.yield();//静态方法，让出当前CPU的使用权,若让出之后其他线程抢不到，那还可以抢回来
                   }
                   System.out.println(this.getName()+"休息一秒："+i);
                   Thread.sleep(1000);//线程休眠
               } catch (InterruptedException e) {
                   e.printStackTrace();
               }
           }
        }
    }
}`
5. join():A线程调用B线程的方法，则A线程阻塞，必须等到B线程执行完以后，A线程才会结束阻塞，继续执行。

`
/**
 * @Description: 启用两个子线程，分别求0-50和51-100的和，并返回给主线程，由主线程求出最终的和
 * @Author: yangyb
 * @Date:2022/5/23 11:58
 * Version: 1.0
 **/
public class TestSum {

    public static void main(String[] args){
        SumThread sumThread = new SumThread(1, 50);
        SumThread sumThread1 = new SumThread(51, 100);

        sumThread.start();
        sumThread1.start();

        try {
            sumThread.join();
            sumThread1.join();
            int sum=sumThread.get()+sumThread1.get();
            System.out.println(sum);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

class SumThread extends Thread {
    int num1,num2,sum;

    public int get(){
        return sum;
    }

    public SumThread(int num1,int num2){
        this.num1=num1;
        this.num2=num2;
    }

    @Override
    public void run() {
        add();
    }

    public void add(){

        for(int i=num1;i<=num2;i++){
            sum+=i;
        }
    }
}`

6. 中断线程：
过时的（deprecated）方法：stop()、suspend()、destroy()、resume()，避免使用，比如stop()方法，使得调用者可以立即终止一个线程，而这个线程可能在进行某些不适合立刻中断的操作，否则会引起比如，被迫释放锁，引起数据不一致，文件，数据库等资源未能关闭等。
interrupt():
A线程调用B线程的此方法，通知B线程，要中断B线程，B线程在自己的run方法里面，通过isInterrupt()或Interrupted()获知此信息，自行决断做何操作。
B线程并不会中断，这个方法只会给线程设置一个为true的中断标志，一旦线程正在调用wait(),join(),sleep()方法中的一种，会立刻抛出一个InterruptedException,B线程可以在catch块中进行进一步处理。
`public class TestInterrupt {

    public static void main(String[] args){

        MyInterruptThread myInterruptThread = new MyInterruptThread();
        myInterruptThread.start();

        try {
            Thread.sleep(1000);
            System.out.println(Thread.currentThread().getName()+"沉睡了一秒钟");
            System.out.println(Thread.currentThread().getName()+"通知子线程中断");
            myInterruptThread.interrupt();//中断子线程
            System.out.println(Thread.currentThread().getName()+"子线程中断完毕");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        myInterruptThread.interrupt();
       }
}

class MyInterruptThread extends Thread{

    @Override
    public void run() {
        try {
            System.out.println("子线程分配资源");
            sleep(5000);
            System.out.println(Thread.currentThread().getName()+"沉睡了五秒钟");
        } catch (InterruptedException e) {
            System.out.println("子线程释放资源");
        }
    }
}
`
#### 4.1.5、线程的优先级
1. JAVA线程中的优先级有1到10共10个等级，等级数越大，优先级越高。有三个常量的等级值：MIN_PRIORITY = 1;NORM_PRIORITY = 5（默认）;MAX_PRIORITY = 10;
2. 可以通过getPriority()方法，得到该值；可以通过setPriority()设置该值。
3. 优先级的设置应该在启动该线程，即调用start()方法之前被设置。
4. 使用CPU资源的时候：同优先级，排队服务，先到先得；在资源有限的情况下，优先级的作用才能体现出来；优先级更多的是给操作系统调度器一个“hint”,至于如何处理，那要看操作系统的调度器实现；线程的高优先级不可以作为线程被优先执行的保证，不要依赖于优先级来写程序；一般对于所有线程使用默认优先级即可。
#### 4.1.6、线程的同步机制
##### 4.1.6.1、举例
创建一个Cat类，包含一个属性age,一个增加年龄的方法addAge(),一个减少年龄的方法minusAge();

`public class Cat {

    int age;
    
    void addAge(){
        System.out.println(Thread.currentThread().getName()+":"+age);
        age++;
        System.out.println(Thread.currentThread().getName()+":"+age);
    }

    void minusAge(){
        System.out.println(Thread.currentThread().getName()+":"+age);
        age--;
        System.out.println(Thread.currentThread().getName()+":"+age);
    }
    
}
`
创建一个测试类，里面创建两个线程，一个用来增加年龄，一个用来减少年龄，看是否能按照我们所想的输出：0110。

`public class Test {

    public static void main(String[] args){

        Cat cat=new Cat();
        //通过Runnable接口创建两个线程
        Thread thread=new Thread(new Runnable(){
            @Override
            public void run(){
                cat.addAge();
            }
        });

        Thread thread1=new Thread(new Runnable(){

            @Override
            public void run(){
                cat.minusAge();
            }
        });

        //一定要记得启动线程
        thread.start();
        thread1.start();
    }
}`
显然，通过运行程序我们发现与我们预期的结果不一样，发生了数据不一致的问题。
##### 4.1.6.1、解决方案
对于同一资源，有多个线程同时访问，导致出现数据不一致的问题，如果我们的程序出现了这种安全隐患问题，就需要进行限制，让同一资源在同一个时间只能被一个线程访问，这种线程访问的安全机制就是“线程同步机制”。
同步指的是让一个个线程排队执行，同指“协同”。
只要在多线程共同访问的方法前面加上synchronized(同步修饰符)，或者把共同运行的代码使用同步代码块synchronized(同步锁提供对象){}括起来，就可以实现同步访问。

1.synchronized(同步修饰符)
`public class Cat {

    int age;
    
    public synchronized void addAge(){
        System.out.println(Thread.currentThread().getName()+":"+age);
        age++;
        System.out.println(Thread.currentThread().getName()+":"+age);
    }

    public synchronized void minusAge(){
        System.out.println(Thread.currentThread().getName()+":"+age);
        age--;
        System.out.println(Thread.currentThread().getName()+":"+age);
    }
}`

2.同步代码块synchronized(同步锁提供对象){}
`public class Test {

    public static void main(String[] args){

        Cat cat=new Cat();
        //通过Runnable接口创建两个线程
        Thread thread=new Thread(new Runnable(){
            @Override
            public void run(){
                synchronized(cat){
                    cat.addAge();
                }
            }
        });

        Thread thread1=new Thread(new Runnable(){

            @Override
            public void run(){
                synchronized(cat){
                    cat.minusAge();
                }
            }
        });

        //一定要记得启动线程
        thread.start();
        thread1.start();
    }
}`

#### 4.1.7、同步锁
1. JAVA中的每个对象都有一把锁，称为固有锁，监视器，同步锁，同步监视器，一般简称锁。
2. 如果一个线程想要独占的执行某个方法，或者某段代码，就需要获得一把锁，把这个方法，或者这段代码锁住，这段时间只允许自己访问。
3. 进入对象的非静态同步方法（synchronized）,默认会使用这个对象this的锁。如果是第一个进去，将自动获得这个锁，但是如果别的线程已经获得，那只能排队等待（同步阻塞）。注意，一个对象上的多个方法，如果都是synchronized修饰，那么他们共用这把锁，因为一个对象只有一个锁。
4. 关键字synchronized也可以用于声名类的静态方法，这时候提供锁的对象是类本身的对象，即类名.class。
5. 锁并不能阻止对象的非同步方法被多线程访问。
6. 进入同步块，则需要借某个对象的锁。如果几个线程想要使用同步一个或者几个代码块，那么他们要使用同一个对象的锁，至于这个对象是什么，并不重要。一般可以使用一个都可以访问到的对象，也可以创造一个Objected类型的对象，甚至可以用某个类的本身即类名.class，这也是一个对象。在用this作为同步锁对象的时候，要注意这个或者这些同步代码块的this是不是同一个对象。
7. synchronized代码块包含住操作共享资源的部分就可以，不要包含过多代码，否则会影响效率，或者影响其他线程使用被包住的非共享资源部分的代码。
8. synchronized方法只能同步方法的本身，即一个线程执行此方法的时候，其他线程不能执行此方法，并且不能执行此对象上的任何synchronized方法，因为这些方法用的是对象本身这同一把锁。但如果一个线程需要调用这个对象的几个synchronized方法完成一个复合的同步操作，这个中间会有间隔，就会释放锁，那么需要使用同步代码块来将几个方法一起锁住（同步）。
9. 因为同步方法在多线程同时访问的时候需要等待，同步方法的执行效率低于非同步方法。 
##### 4.1.7.1、Lock同步锁
1. 同步方法、同步代码块都是通过同步关键字synchronized来实现的,JDK5以后，提供了一种方式来实现同步访问，即Lock,在java.util.concurrent.locks里面。
2. Lock是接口，而synchronized是关键字，是通过内置语言来实现的。
3. ReentrantLock是Lock接口的实现类，是可重入锁，即如果已经有一个对象锁，那么当它调用同一对象的其他同步方法的时候，就不需要再次申请这个对象的锁。
4. ReentrantLock和synchronized都是可重入锁。
5. lock(),手动加锁
6. ReentrantLock(true)传入true,表示等待锁的线程，按先到先得的顺序公平使用锁，那就是公平锁；不传该参数，这个参数默认为false，就是非公平锁，所以ReenTrantLock默认就是非公平锁，无法保证等待的线程获取锁的顺序。
7. tryLock(1, TimeUnit.MILLISECONDS),尝试拿到锁，若成功则返回true,失败，会等待一段时间，再次尝试拿锁。
8. tryLock()尝试拿到锁，若成功则返回true,失败，返回false.
9. unlock(),手动解锁。若忘记释放锁，则有可能造成死锁，即使发生异常也要释放锁，为了避免这种情况的发生，一般写在finally块中解锁。
示例代码：

`public class Testlock {

    public static void main(String[] args){

        Cat cat = new Cat();

        Lock lock=new ReentrantLock();//创建一个可重入锁
        new Thread(new Runnable(){

            @Override
            public void run() {
                try {
                    if (lock.tryLock(1, TimeUnit.MILLISECONDS)) {
                        try {
                            lock.lock();//加锁
                            System.out.println(Thread.currentThread().getName() + ":" + cat.getAge());
                            cat.addAge();
                            System.out.println(Thread.currentThread().getName() + ":" + cat.getAge());
                        } finally {
                            lock.unlock();//释放锁
                        }
                    }
                } catch (InterruptedException e) {
                    System.out.println(Thread.currentThread().getName() + "没有拿到锁");
                }
            }
        }).start();

        new Thread(new Runnable(){

            @Override
            public void run(){
                try {
                    if (lock.tryLock(1, TimeUnit.MILLISECONDS)) {
                        try {
                            lock.lock();//加锁
                            System.out.println(Thread.currentThread().getName() + ":" + cat.getAge());
                            cat.minusAge();
                            System.out.println(Thread.currentThread().getName() + ":" + cat.getAge());
                        }finally{
                            lock.unlock();//释放锁
                        }
                    }
                } catch (InterruptedException e) {
                    System.out.println(Thread.currentThread().getName() + "没有拿到锁");
                }
            }
        }).start();
    }
}
`
`public class Cat {

        int age;
        void addAge(){
            age++;
        }

    void minusAge(){
        age--;
    }

    public int getAge(){
        return age;
    }
}`

##### 4.1.7.2、死锁
两个或多个线程，在各自使用一把锁的时候，为了完成当前的执行，需要使用对方正在使用的锁，这样一来，双方都在等待对方释放手中的锁，就造成循环等待，发生了死锁。死锁发生后，并不会发生异常，难以调试。
`public class DeadLock {

    public static void main(String[] args){

        Object o1=new Object();
        Object o2=new Object();

        new Thread(new Runnable(){

            @Override
            public void run(){
                synchronized(o1){
                    try {
                        Thread.sleep(1000);
                    }catch (InterruptedException e){
                        e.printStackTrace();
                    }
                    System.out.println(Thread.currentThread().getName()+"等待o2的锁");

                    synchronized(o2){
                        System.out.println(Thread.currentThread().getName()+"执行了代码");
                    }
                }
            }
        }).start();

        new Thread(new Runnable(){

            @Override
            public void run(){
                synchronized(o2){
                    try {
                        Thread.sleep(1000);
                    }catch (InterruptedException e){
                        e.printStackTrace();
                    }
                    System.out.println(Thread.currentThread().getName()+"等待o1的锁");

                    synchronized(o1){
                        System.out.println(Thread.currentThread().getName()+"执行了代码");
                    }
                }
            }
        }).start();
    }
}`
避免死锁：
1. 嵌套锁，即已经锁住了 一个资源，同时再锁住另一个资源。在多线程的情况下，完全避免一个线程使用多个锁来完成任务，并不现实。所以理清锁的顺序，避免交互加嵌套锁造成死锁。
2. 可以通过Lock回避死锁。比如使用tryLock()回避死锁问题。 
#### 4.1.8、wait-notify机制
1. 每个对象从Object类继承下来，就拥有了一把锁（监视器），wait(),notify(),notifyAll()方法，一个锁池，一个等待池。
2. 线程可以在synchronized的同步方法，和同步块里面使用一个对象锁来锁定资源，也可以调用对象的这几个方法实现wait和notify。
3. 注意，对象的wait(),notify(),notifyAll()方法只能在对象自己锁定的同步代码块或者同步方法中被调用。
4. 如果一个线程想要获取锁，若果锁已经被占用了，则此线程进入锁池，称为阻塞(blocked)。
5. 如果线程t已经拥有锁，在需要某些条件，暂时不执行了，则可以调用锁对象.wait()，释放锁，进入等待池，等待条件满足了，别的线程调用锁对象.notify()后，线程t从等待池再次进入锁池，等到线程t竞争到锁后，再从wait()方法处向后执行。
6. 也可以调用锁对象.wait(时间)，如果没有等到notify，等待的时间到，则进入锁池。
7. 锁对象.notify()，从等待池中随机选一个线程，放入锁池。
8. 锁对象.notifyAll()，将所有等待池中的线程，放入锁池。
9. 两个或者多个线程，可以使用同一把锁的wait(),和notify()方法相互协作，实现线程间的通讯。

`public class WaitNotify {

    public static void main(String[] args){

        Object o = new Object();

        new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (o) {
                    System.out.println("2、子线程通知主线程，主线程满足条件，可以进入该对象的锁池！");
                    o.notify();
                }
                System.out.println("3、子线程释放锁！");
            }
        }).start();

        synchronized (o){
            try {
                System.out.println("1、主线程不满足条件，进入该对象的等待池！");
                o.wait();
                System.out.println("4、主线程满足，从等待池释放进入该对象的锁池！，并且拿到了锁，继续执行");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}`
#### 4.1.9、park和unpark

1. park()和unpark()不是线程的方法，也不是锁对象的方法，而是LockSupport类中的两个静态方法，这个类位于java.util.concurrent.locks包中。
2. 用法：
* 在线程t1中调用LockSupport.park()，用于暂停当前线程t1的运行。
* 在另外的线程调用LockSupport.unpark(t1)，恢复线程t1的运行。
* 比如：t1先park,过段时间t2中再unpark(t1),t1继续从park处执行；或者t2先提前unpark(t1),过段时间t1再park,t1会继续执行，注意，unpark不能累加。这两种顺序，代码都可以执行。
* 注意，park和unpark虽然也可以实现线程间通讯，但是与wait-notify不同，不需要在synchronized同步代码块中进行。
* 也可以执行park的时间，如果时间到了，没有等到unpark，也会恢复线程运行。parkNanos(纳秒)，1纳秒=十亿分之一秒；parkUntil(截止时间)，截止时间为从Epoch(1970年1月1午夜)开始的毫秒数。

`public class ParkAndUnpark {

    public static void main(String[] args){

        Thread t1 = new Thread(new Runnable() {

            @Override
            public void run() {
                System.out.println(Thread.currentThread().getName()+":t1开始执行");
                park();
                System.out.println(Thread.currentThread().getName()+":t1执行结束");
            }
        });

        Thread t2 = new Thread(new Runnable() {

            @Override
            public void run() {
                System.out.println(Thread.currentThread().getName()+":t2开始执行");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                unpark(t1);
                System.out.println(Thread.currentThread().getName()+":t2执行结束");
            }
        });

        t1.start();
        t2.start();
    }
}`
#### 4.1.10、比较sleep和wait
1. 两个方法都是使用当前线程释放CPU，进入睡眠或等待。
2. sleep()是线程的静态方法，通过Thread.sleep()来调用；而wait()是锁对象的方法。
3. sleep()不强制要求和synchronized配合使用，而wait()方法需要和synchronized一起使用。
4. 使用Thread.sleep()使得当前线程进入睡眠，当前线程如果持有锁，并不会释放锁；而锁对象.wait()使得当前线程进入当前锁对象的等待池，会释放锁。
#### 4.1.11、比较park-unpark和wait-notify
1. 两者都可以实现线程间通讯。
2. wait-notify是属于锁对象的，需要在锁的synchronized同步代码中被锁对象调用；park和unpark与synchronized同步代码无关，是属于LockSupport的静态方法，直接就可以执行。
3. unpark可以具体唤醒某个线程，而notify只能随机唤醒一个等待的线程，notifyALL是唤醒所有等待线程。
4. park和unpark可以先unpark,这个unpark依然可以对后面的park起作用；而wait-notify如果先notify，则不会对后面的wait起作用。
#### 4.1.12、回调（Callback）
1. 回调方法是指一个方法当一个事件发生的时候被调用，通常可以使用接口来定义回调方法，再把一个接口的实现传递到负责触发这个事件的系统中去。
2. 简单的说:回调是指把一段代码，传递给另外一段代码，让第二段代码来执行第一段代码。
#### 4.1.13、同步调用和异步调用
1. 同步调用是基本的调用方式，调用者要等待（被阻塞）被调用者返回，才会继续执行。一般的方法调用，就是同步调用。比如：线程t1中调用类B的方法b()，一直等待b()方法执行完毕，t1才继续往下走。
2. 异步调用，调用者不需要等待（非阻塞）被调用者返回，调用者在调用被调用者后，会立即继续执行。比如：线程t1通过新启动线程的方式调用另外的代码，t1的代码会接着往下执行。
3. 这两种调用方式的最大区别，就是同步调用需要等待被调用者返回，而异步调用不需要等待。使用多线程的异步调用方式，可以在被调用线程执行号是任务的时候，调用线程可以继续执行代码，这是一种非阻塞的处理。
#### 4.1.14、线程池
1. 对于大量使用线程，并且线程执行时间比较短，就会需要频繁创建和销毁线程，线程的创建和销毁比较耗费计算机资源，也提高了软件编写中对于线程调度的要求。
2. 使用线程池，可以维护多个线程供直接使用，复用，并可以获得线程池提供的对于线程的管理和调度。
* 节约资源：线程创建和销毁造成比较耗费资源，重复使用现成的线程可以节约资源。
* 提高响应：可以立刻拿现成的线程使用，不需要等待线程创建。
* 可管理性：可以对线程进行统一的分配，管理，和优化。
3. 线程池原理
* 线程池里面使用了一个生产者-消费者模型：任务管理和线程管理。
* 用户将任务，即业务逻辑写在Runnable接口实现类或者Callable接口实现类里面，然后提交给线程池。
* 线程池会给任务分配线程，让线程运行任务。
4. 线程池的创建
 * 使用Executors工具类来创建线程池对象ThreadPoolExecutor，以ExecutorService接口返回。
 * 通过ExecutorService接口来执行任务。
 * 使用完线程池，使用ExcutorService要关闭shuntdown()。
 * 可以通过ThreadPoolExecutor可以设置线程池配置参数，一般不需要设置，Executors创建线程池的时候已经默认设置。
 
`public class PoolTest {

    public static void main(String[] args){

        ExecutorService executorService=Executors.newFixedThreadPool(10);
        executorService.execute(new MyRun());
        executorService.shutdown();

    }
}

class MyRun implements Runnable{

    @Override
    public void run(){

        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName()+":执行了任务！");
    }
}
`
#### 4.1.15、线程的生命周期
1. Thread.State
* NEW(新建)：还没有调用start();
* RUNNABLE(可运行的)：可以运行的状态，进一步分为就绪(READY，等待CPU使用权)与运行(RUNNING,正在运行)。
* BLOCKED(阻塞)：现在在等待监视器锁，即synchronized设定的对象内置锁。
* WAITING（等待）：线程无期限等待，等待其他线程执行一个特定动作。
* TIMED_WAITING(限时等待)：线程等待其他线程执行一个特定动作，最多等待设定的时间。
* TERMINATED(终止)：线程生命周期结束。
### 4.2、反射
#### 4.2.1、反射的概念
##### 4.2.1.1、反射（reflection）
1. 反射机制允许程序在运行时，通过反射API
* 获取或加载一个“类本身”的对象。
* 进而，获取类的内部信息。
* 进而，创建对象，操作对象的属性和方法。
2.这种运行时“看透类”的能力，动态获取的类的信息，创建对象，调用方法的功能称为反射。反射被视为动态语言的重要特点。
##### 4.2.1.2、动态语言
 1. 一般有这样的观点“程序运行时，允许改变程序结构或变量类型，这种语言称为动态语言”。从这个观点看，Perl,Python,Ruby是动态语言，C/C++,Java,C#不是动态语言。
 2. 但Java的反射使得其具有动态语言的特征。JAVA可以在运行时加载、探知、使用编译期间完全未知的类。
##### 4.2.1.2、反射的特点
1. 反射使代码更加灵活，极大提高了代码的运行时装配能力，强化了多态的特性。反射是构建框架技术的基础。
2. 但是反射的效率要比正常操作低，因为JVM难以对反射中的动态代码进行优化。当然反射的适量使用，性能不会是一个问题。
#### 4.2.2、Class类
1. 一个类被JVM加载，其.class文件被读入内存，JVM自动为之创建一个java.lang.Class对象，这个Class对象称为运行时类，Class对象代表着在内存中的“类本身”。
2. 通过Class对象可以访问该类的信息。
3. 一旦类被加载到JVM中，同一个类将不会被再次载入。
4. Class的对象代表加载入内存的类，Class是类的类，称为元类。
5. 一个类的Class对象代表着在内存中的这个类的“类本身”，和面向对象编程要先建立类一样，对某个类使用反射需要先得到这个类的Class对象。
6. 获得Class对象的4种方式
* 类名.class
* 对象.getClass()
* Class.forName("包名+类名")
* 使用类加载器ClassLoader.getSystemClassLoader().loadClass("包名+类名")

`package com.company.reflex;
public class Cat {
}`

`public class ReflexText {
    public static void main(String[] args) {
        Class<Cat> catClass = Cat.class;
        System.out.println(catClass.getName());

        Cat cat = new Cat();
        Class<? extends Cat> aClass = cat.getClass();
        System.out.println(aClass.getName());

        try {
            Class<?> aClass1 = Class.forName("com.company.reflex.Cat");
            System.out.println(aClass1.getName());
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }

        try {
            Class<?> aClass1 = ClassLoader.getSystemClassLoader().loadClass("com.company.reflex.Cat");
            System.out.println(aClass1.getName());
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}`
### 4.3、设计模式
1. 创建型、结构性、行为型
2. OOP七大原则：
* 开闭原则：对拓展开放，对修改关闭。
* 单一职责原则：控制类的粒度大小，将对象解耦、提高其内聚性。
* 接口隔离原则：要为各个类建立它们需要的专用接口。不同的类使用同一个接口的部分方法时，应该将每个类对应的方法从接口中抽离出来分别实现。
* 依赖倒置原则：要面向接口编程，不要面向实现编程。高层模块不应该依赖底层模块，二者都依赖其抽象。程序要依赖于抽象接口，不要依赖于具体实现。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。
* 里氏替换原则：继承必须确保超类所拥有的性质在子类中仍然成立。超类能出现的地方，可以用子类代替，子类拥有超类的所有属性和方法，通俗来说子类拥有超类的功能，可以拓展超类的功能，但是不能修改超类的功能。
* 迪米特法则：也叫最少知道原则。只与你的直接朋友交谈，不跟“陌生人”说话。两个对象之间有耦合关系，说明对象间是朋友关系。出现在成员变量，方法参数，方法返回值中的类为直接朋友；出现在局部变量中的类就是陌生朋友。
* 合成复用原则：尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。判断组合和聚合关系的一个简单方法就是：看整体与部分的生命周期是否一致，部分能够独立于整体而存在则属于聚合；整体消失部分不复存在则属于组合。
#### 4.3.1、单例模式
##### 4.3.1.1、什么是单例？
Singleton Pattern 是确保一个类在任何情况下，只有一个实例，并提供一个全局访问点。
##### 4.3.1.1、懒加载（懒汉式）
```
public class Singleton {

    private static Singleton instance=null;//初始化对象为空，只有在需要用到这个对象的时候才去初始化
    //构造器私有
    private Singleton(){

    }

    //提供一个全局的访问点
    public static Singleton getInstance(){
        if(instance==null){
            instance=new Singleton();
        }
        return instance;
    }
}
```
对于创建开销比较大的类的实例，此方法使用，节约资源。但这个例子在构建方法上没有加同步关键字或者锁，所以在多线程情况下不安全。
改造一下，在方法上加上synchronized关键字试试：
```public class Singleton {

    private static Singleton instance=null;//初始化对象为空
    //构造器私有
    private Singleton(){

    }

    //提供一个全局的访问点
    public static synchronized Singleton getInstance(){
        if(instance==null){
            instance=new Singleton();
        }
        return instance;
    }
}
```
其实我们只想在构建对象的时候同步线程，而这样的话每次构建对象的时候都要进行同步操作，对性能影响非常大，显然得不偿失。
再改造一下，只需要将初始化对象的语句加个synchronized代码块即可。
```
public class Singleton {

    private static Singleton instance=null;//初始化对象为空
    //构造器私有
    private Singleton(){

    }

    //提供一个全局的访问点
    public static  Singleton getInstance(){
        if(instance==null){
            synchronized (Singleton.class){
            instance=new Singleton();
           }
        }
        return instance;
    }
```
显然，多线程情况下，依然会出现重复构建的问题。
所以再进一步改造一下：双检锁
```public class Singleton {

    private  volatile static Singleton instance=null;//初始化对象为空
    //构造器私有
    private Singleton(){

    }

    //提供一个全局的访问点
    public static  Singleton getInstance(){
        if(instance==null){
            synchronized (Singleton.class){
                if(instance==null){
                    instance=new Singleton();
                }
           }
        }
        return instance;
    }
}
```
##### 4.3.1.2、饿汉式
编译期构建对象，运行期调用即可
```public class Singleton {

    private static Singleton instance=new Singleton();//初始化对象为空
    //构造器私有
    private Singleton(){

    }

    //提供一个全局的访问点
    public static synchronized Singleton getInstance(){
        return instance;
    }
}
```
##### 4.3.1.3、静态内部类
```public class Singleton {

    //静态内部类
    private static class SingletonHolder{
        private static final Singleton INSTANCE=new Singleton();
    }

    //构造器私有
    private Singleton(){

    }

    //提供一个全局的访问点
    public static  Singleton getInstance(){

        return SingletonHolder.INSTANCE;
    }
}
```
#### 4.3.2、工厂模式
实现了创建者和调用者的分离。
1. 核心本质：
* 实例化对象不使用new，用工厂方法代替。
* 将选择实现类，创建对象统一管理和控制。从而将调用者跟我们的实现类解耦。
2. 三种模式：
* 简单工厂模式：用来生产同一等级结构中的任意产品（对于增加新的产品，需要覆盖已有代码）
* 工厂方法模式：用来生产同一等级结构中的固有产品（支持增加任意产品）
* 抽象工厂模式：围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。
3. 总结：
 * 简单工厂模式(静态工厂模式)，虽然某种程度上不符合设计原则，但实际使用最多。
 * 工厂方法模式，不修改已有类的前提下，通过增加新的工厂类实现扩展。
 * 抽象工厂模式，不可以增加产品，可以增加产品族。
 4. 应用场景：
 * JDK中Calendar的getInstance。
 * JDBC中的Connection对象的获取。
 * Spring中IOC容器创建管理bean对象。
 * 反射中Class对象的newInstance方法。
#### 4.3.3、代理模式
### 4.4、网络编程

### 4.5、JVM
双亲委派机制？
### 4.6、注解（Annotation）
1. 又称为标注，是JDK5.0引入的一种注释机制。与类、接口、枚举是在同一个层次。
2. 注解以“@注解名”进行使用，比如，方法重写中使用过的@Override。
3. 注解可以标注在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行标注。通过分析工具和开发工具等，可以在编译、类的加载、运行时候，可以对这些注解进行某些处理。
#### 4.6.1、编译检查注解
1. JDK中内置的三个基本注解
2. @Override用于重写方法，编译期会检查被注解的方法，确保该方法是重写了基类的方法，否则会有编译错误。
3. @Deprecated用来指示API已经过时了，不推荐使用。
4. @SuppressWarnings如果你确认程序中的警告没有问题，但是不想看到这些警告，可以用这个注解来抑制编译器警告。
#### 4.6.2、自定义注解
1. 用@interface关键字来声名注解，注解也会生产.class文件。
2. 注解可以有成员变量，在使用注解的时候要给成员变量赋值。可以使用default来定义默认值。用以下方式来声名成员变量：
* 成员类型 成员名();
3. 成员类型可以为基本数据类型、String、Class、enum、Annotation，以及相应的数组。
4. 如果只有一个成员，成员名通常用value。
5. 使用时必须指定参数值，除非它有默认值。格式是“参数名=参数值”，如果只有一个参数成员，且名称为value，也可以直接写“参数值”。
6. 没有成员变量的注解也称为标记，有成员变量的注解称为元数据注解。
##### 4.6.2.1、编写注解处理器解析注解
1. 使用注解主要目的就是为了可以读取注解并进行使用。
2. 在注解处理器中，可以使用反射机制来从使用注解的类中读取这个类的结构信息（属性，方法，构造器等），并可以获取注解的信息，进行动态处理（运行时这些信息进行处理）。  
```public class CustomAnnotationTest {

    public static void main(String[] args){

        //通过反射获取类的信息
        Class<CustomAnnotationTest> customAnnotationTestClass = CustomAnnotationTest.class;

        for (Method m:customAnnotationTestClass.getMethods()
             ) {
            MyAnnotation annotation = m.getAnnotation(MyAnnotation.class);
            if(annotation!=null){
                System.out.println(m.getName());
                System.out.println(annotation.name());
                System.out.println(annotation.age());
            }

        }
    }

    @MyAnnotation(name = "张三")
    public void test(){

    }

    @MyAnnotation(name = "李四",age = 22)
    public void test1(){

    }
}
//自定义注解
@Retention(RetentionPolicy.RUNTIME)
@interface MyAnnotation{
    String name();
    int age() default 18;
}
```
#### 4.6.3、元注解（meta-annotation）
元注解是对其他注解进行说明的注解。当自定义一个新的注解类型时，可以使用元注解对其进行说明。
常见的几个元注解
##### 4.6.3.1、@Target
1. 指明某个注解的作用目标。若不设置，则可以放在所有元素前。
2. 可以使用枚举ElementType的值来添加参数，设定具体的作用目标。
* TYPE:接口、类、枚举、注解
* FIELD：字段、枚举的常量
* METHOD：方法
* PARAMETER:方法参数
* CONSTRUCTOR：构造参数
## 5、微服务
### 5.1、SpringCloud
#### 5.1.2、缓存
redis、memarycache
#### 5.1.3、消息中间件
RabbitMQ、activemq、rocketMQ、socketmq等
#### 5.1.4、注册中心
Nacous、Eureka、zookeeper
#### 5.1.5、网关
Gateway、Zuul
#### 5.1.6、断路器
Hystrix、sentinel
#### 5.1.7、负载均衡
Nginx、Ribbon
#### 5.1.8、Bus
#### 5.1.9、Tomcat
#### 5.1.10、Netty
## 6、计算机网络
### 6.1、DNS是什么？
### 6.2、cookie和session异同?
cookie和session都是用来存储用户信息的。
为什么要使用cookie？由于http协议是一种无状态的协议，这会导致客户端和服务端无法相认。
cookie存储在客户端，session存储在服务端。
cookie数据量最大为4K,session的数据量大小没有限制。
## 7、数据结构和算法
## 8、简历优化