# 复习规划
## 1.JAVA基础
### 1.1、JAVA基本数据类型
答：分四类，公8种。
1. 整型：byte(1),short(2),int（4），Long(8);
2. 浮点型：float(4),double(8);
3. 布尔型：boolean：true,false;
4. 字符型：char(2)
### 1.2、Java类和对象的概念
JAVA是面向对象的编程语言，类是对象的抽象表示，对象是类的实例。
#### 1.2.1、类与类之间的关系
关联、聚合、组合、依赖、继承、实现
### 1.3、Java面向对象的三个特征？
封装、继承、多态。
#### 1.3.1、封装
通过访问修饰符public、null、project、private来实现。可以限制性的访问类和对象的方法、属性。
#### 1.3.2、继承
子类可以继承父类所有的东西，但是子类看不到父类private的属性和方法。
#### 1.3.3、多态
将子类的引用赋值给一个父类对象，这样子类可以重写父类的方法，也可以扩展拥有自己的属性和方法。
### 1.4、抽象方法、抽象类、接口
#### 1.4.1、抽象方法、抽象类
抽象方法、抽象类通过abstract关键字修饰。
含有抽象方法的类必须是抽象类，因为如果某个拥有抽象方法的类被其子类继承，并去掉这个父类的抽象方法，而抽象方法是没有方法体的，这时候应该输出什么呢？
答：编译器肯定会报错，所以这个时候就只能将这个父类也声名为抽象类，这样其子类就必须去重写它的抽象方法，这样就这个问题就解决了。当然如果这个子类不需要重写这个抽象方法，那也可以将自己也定义为抽象类即可。
一个类只能继承一个父类，即单继承。
#### 1.4.2、接口
通过interface关键字修饰。接口里面有常量和抽象方法，就是通过实现该接口的类去重写抽象方法，从而实现多态。
一个类可以实现多个接口。
万事万物皆对象，面向对象编程，面向接口编程。
JDK8以后，接口里面可以有静态方法（static）和默认方法（default）。  
### 1.5、封箱和拆箱
### 1.6、异常处理
#### 1.6.1、 JAVA处理异常的思路：
一是自己捕获处理，即加try(){}catch(){};
二是处理以后再向上抛出；
三是直接向上抛出(throw e)异常,对应的方法上也要加上throws e，甚至可以将异常抛给main方法，最终交由JVM去处理，当然不推荐这样做。
#### 1.6.2、JAVA程序的错误：
1. 代码错误，一般编译器就会帮我们指出。
2. 逻辑错误，需要测试，才能排查出来。
3. 程序运行期发生的错误。这种错误也分三种，一种是error，比如内存溢出等，这种不用出来，JVM会报错，直接终止程序；第二种是运行时异常（RuntimeException），也叫非受检查异常，也不用处理，JVM会处理，打出堆栈错误，终止程序等等；第三种是除前两种意外的异常（空指针等），也叫受检查异常或非运行时异常，需要我们去处理，必须捕获处理，或向上抛出。
4. 自定义异常
#### 1.6.3、therow和throws的区别？
throw用于在方法内部抛出异常，throws用于方法之上，两者一般是成对出现。
### 1.7、IO流
### 1.8、集合
JAVA中的集合又称容器，是对数据结构的一种实现，通过集合，我们可以完成对数据的增删改查，方便程序员管理数据。
JAVA中集合中的数据是存储在内存当中的，是一种临时的数据存储方式，当服务器重启或出现故障的情况下，集合中的数据就会消失。
#### 1.8.1、JAVA集合体系
![JAVA集合体系](vx_images/168244017220562.png =998x)
#### 1.8.2、Collection接口
1. List和Set集合的父接口，当然还有其它的实现类或子接口。
#### 1.8.3、List接口
Collection接口的子接口，存储有序，可重复的数据。
#### 1.8.4、ArrayList
数据结构：数组，相对于链表，查询快，增删慢。
常用方法：
` List<String> arrayList=new ArrayList<>();
        arrayList.add("尾");//尾加
        arrayList.add(1,"一");//插入
        arrayList.add(1,"二");//插入一个新值，原先在这个位置上的将往后移一位
        arrayList.set(1,"3");//覆盖掉原先在这个位置上的值
        arrayList.remove(0);
        arrayList.remove("一");
        //遍历方式：1、for循环、2、增强for、3、迭代器iterator
        Iterator<String> iterator = arrayList.iterator();
        while (iterator.hasNext()){
            System.out.println(iterator.next().toString());
        }`
扩容机制：1.5N,生成一个新的数组，将原来的数组复制到新的数组中。删除同理。
`
//默认长度10
private static final int DEFAULT_CAPACITY = 10;
`
不足点：线程不安全，方法无synchronized修饰等。与之对应的Vector是线程安全的。
#### 1.8.5、LinedkList
数据结构：双向非循环链表，相对于数组，增删快，查询慢。
常用方法：
` LinkedList<String> linkedList=new LinkedList<>();
        linkedList.add("一");
        linkedList.add("二");
        linkedList.addLast("tail");
        linkedList.addFirst("head");
        System.out.println(linkedList.toString());//[head, 一, 二, tail]
        linkedList.remove("一");
        System.out.println(linkedList.toString());//[head, 二, tail]`
不足点：线程不安全，方法无synchronized修饰等。
#### 1.8.6、Set
Set继承了Collection接口，里面没有额外的方法。
实现无序（这里的无序是指和元素的添加顺序不一致而已，其实里面有排序规则），不可重复的数据集合。
#### 1.8.7、HashSet
数据结构：基于HashMap实现。
特点：存储无序，不可重复的数据。没有根据索引操作数据的方法。
常用方法：
`Set<String> hashSet=new HashSet<>();
        hashSet.add("a");
        hashSet.add("b");
        hashSet.add("c");
        hashSet.add("a");//有重复则覆盖
        hashSet.remove("c");
        for (String s:hashSet
             ) {
            System.out.println(s.toString());
        }`
#### 1.8.10、TreeSet
数据结构：基于TreeMap实现。
常用方法：
`  TreeSet<String> treeSet= new TreeSet<>();
       treeSet.add("a");
       treeSet.add("b");
       treeSet.add("c");
       treeSet.add("a");//覆盖掉相同的值
       treeSet.remove("c");
        for (String s:treeSet
             ) {
            System.out.println(s.toString());
        }`
#### 1.8.11、Map接口
Map接口是独立的接口，和Collection没关系。
Map中的每一个元素都是一个entry类型，每个元素包含key(键)和value(值)。
Map存储无序（指和添加元素时的顺序不一致），不可重复的元素。
#### 1.8.12、HashMap
HashMap是对散列表的具体实现。
数据结构：数组+链表。
`Map<String,Object> hashMap=new HashMap<>();
        hashMap.put("1","张三");
        hashMap.put("2","张三");
        hashMap.put("3","李四");
        hashMap.put("3","李四四");//key相同则覆盖掉原来的值
        hashMap.put(null,null);//只允许一个key为null
        hashMap.put("4",null);//可允许多个value为null
        //遍历：
        //keySet遍历：
        for (String key:
                hashMap.keySet()) {
            System.out.println(key);
        }
        //entry遍历
        for (Map.Entry<String,Object> entry:
             hashMap.entrySet()) {
            System.out.println("key:"+entry.getKey().toString()+";"+"value:"+entry.getValue());
        }
`
不足：线程不安全。
特点：只允许一个key为null,多个value为null，但遍历取值的时候有可能报空指针异常。
#### 1.8.13、TreeMap
数据结构：红黑树。
特点：和HashMap类似，不允许key为null。
常用方法：
` Map<String,Integer> treeMap=new TreeMap<>();
        treeMap.put("张三",20);
        treeMap.put("李四",30);
        treeMap.put("王麻子",40);
        treeMap.put("王麻子",43);//key重复，则覆盖掉原来的value
        treeMap.put(null,43);//不允许key为null的情况,若为key为空，则会报空指针的错误
        treeMap.remove("李四");
        //遍历 1、keySet()
        for (String key:treeMap.keySet()) {
            System.out.println(key);
        }
        //遍历 2、entrySet() 遍历
        for (Map.Entry<String,Integer> entry:treeMap.entrySet()) {
            System.out.println(entry.getKey()+":"+entry.getValue());
        }
`
#### 1.8.14、Iterator
迭代器，是一个接口，每一个集合的实现类的内部基本都有对Iterator的实现，通过Iterator可以实现对集合的遍历。
存在的意义：隐藏集合内部的实现细节，无论那种集合都是通过Iterator操作，而不是直接操作该集合。
实例化：每个集合都有.iterator()方法，该方法的返回值就是一个迭代器对象。
示例：
` List<String> arrayList=new ArrayList<>();
        arrayList.add("尾");//尾加
        arrayList.add(1,"一");//插入
        arrayList.add(1,"二");//插入一个新值，原先在这个位置上的将往后移一位
        arrayList.set(1,"3");//覆盖掉原先在这个位置上的值
        arrayList.remove(0);
        arrayList.remove("一");
        //遍历方式：1、for循环、2、增强for、3、迭代器iterator
        Iterator<String> iterator = arrayList.iterator();
        while (iterator.hasNext()){
            System.out.println(iterator.next().toString());
            iterator.remove();//删除当前值
        }`
#### 1.8.15、Collections
Collections是一个工具类型，一个专门操作集合的工具类
常用方法：
`List<Integer> arrayList=new ArrayList<>();
      arrayList.add(5);
      arrayList.add(3);
      arrayList.add(1);
      arrayList.add(2);
      arrayList.add(4);
      System.out.println(arrayList.toString());//[5, 3, 1, 2, 4]
      Collections.sort(arrayList);//排序
      System.out.println(arrayList.toString());//[1, 2, 3, 4, 5]
       //添加多个值到集合当中
        Collections.addAll(arrayList,7,8,9,67,68,69);
        System.out.println(arrayList.toString());//[1, 2, 3, 4, 5, 7, 8, 9, 67, 68, 69]
        //取最大值，最小值
        Integer max = Collections.max(arrayList);
        System.out.println(max);//69
        Integer min = Collections.min(arrayList);
        System.out.println(min);//1`
### 1.9、泛型
### 1.10、枚举
## 2、主流框架
### 2.1、SpringMVC
#### 2.1.1、Aop和IOC(DC)
#### 2.1.2、常用组件
#### 2.1.3、执行流程
#### 2.1.4、拦截器和过滤器的区别
### 2.2、SpringBoot
#### 2.2.1、执行原理
#### 2.2.2、常见注解
@Resource和@Autowired异同
### 2.3、持久层框架
#### 2.3.1、MyBaits
##### 2.3.1.1、执行原理
##### 2.3.1.2、#和$的区别
## 3、数据库
### 3.1、MySQL
#### 3.1.1、三大范式
#### 3.1.2、事务与ACID
#### 3.1.3、索引
1. 索引失效
2. 索引类型
#### 3.1.4、存储引擎
#### 3.1.5、JDBC驱动执行顺序（MyBatis执行原理）
#### 3.1.6、SQL执行顺序
from、on、join、where、group by  having、select、distinct、union、order by
#### 3.1.7、常见聚合函数
### 3.2、Oracle
#### 3.2.1、函数、存储过程、视图
## 4、JAVA高级
### 4.1、多线程
#### 4.1.1、并行与并发
并行：指多个任务同时进行，强调的是各个任务之间的独立性和实时性。计算机中指多个处理器同时执行多个任务。
并发：在一个系统内，当资源有限的情况下，通过并发设计，达到部分并行的效果。计算机中指一个处理器，按一定的设计，尽可能达到同时处理多个任务的效果。
#### 4.1.2、进程与线程
进程：
1. 一个正在进行的程序。一个进程中可以使用多个线程来实现并发设计，从而达到并行的效果。
2. 一个进程有自己的内存资源。
3. 一个进程有自己的生命周期，包括创建、生存、消亡等。
线程：
1. 进程的基本单位。在JAVA程序中，程序从一个主线程（main线程）开始，主线程可以创建其他的线程。
2. 线程也有自己的生命周期。创建、生存、消亡等。
3. 线程是进程的一个组件，一个进程中的多个线程可以共享这个进程的内存等资源。
#### 4.1.3、Java程序、JVM实例、用户线程（User Thread）、守护线程(Daemon Thread)
1. 以JAVA命令启动的JAVA程序，都会新增一个JVM实例。一旦程序结束，JVM实例也就销毁了。每个程序都会获得自己的JVM实例和对应的OS级进程，并且每个JVM实例相互独立。
2. 每个JAVA程序运行在单独JVM实例上，每一个JVM实例对应唯一的一个堆，所以一个JAVA程序中的多个线程也就运行同一个JVM实例之上，因此这些线程之间会共享这块堆内存，鉴于此，多线程在访问堆中数据时需要进行线程同步。
3. 守护线程是为其他的线程提供便利服务的，当用户线程结束时，守护线程也就没有存在的意义了，也会销毁。
4. mian线程就是一个用户线程，GC(垃圾回收器)就是一个守护向线程。GC随主线程从开始到结束。
#### 4.1.4、JAVA中创建线程
`public class Test {
    public static void main(String[] args) throws Exception {
    
        //1、继承Thread类，重写run()方法，在run()方法里面写具体的逻辑。
        //注意用对象调用的时候是调start()方法启动线程，线程启动之后JVM会自动去再掉run()方法。
        //永远不要启动一个线程超过一次，即使这个线程启动完毕，也不要再启动该线程。
        //Thread类里面的run()方法只是一个方法，不能用于启动线程。源码中有标注。
        MyThread myThread=new MyThread();
        myThread.start();
        
        //2、实现Runnable接口，重写run()方法，在run()方法里面写具体的逻辑。注意用对象调用的时候是调run()方法。
        MyRunnable myRunnable = new MyRunnable();
        myRunnable.run();
        
        //3、实现Callable<T>接口，重写call()方法，在call()方法里面写具体的逻辑。
        //特点：有返回值，返回值的类型就是实现该接口时传进去的泛型T。
        MyCallable myCallable = new MyCallable();
        myCallable.call();
        
        for(int i=0;i<100;i++){
             System.out.println("main："+i);
         }
    }
}

class MyThread extends Thread{

    @Override
    public void run() {
        for(int i=0;i<100;i++){
            System.out.println("MyThread："+i);
        }
    }
}

class MyRunnable implements Runnable{

    @Override
    public void run() {
        for(int i=0;i<100;i++){
            System.out.println("MyRunAble："+i);
        }
    }
}

class MyCallable implements Callable<String>{

    @Override
    public String call() throws Exception {
        for(int i=0;i<100;i++){
            System.out.println("MyCallable："+i);
        }
        return null;
    }
}
`
##### 4.1.4.1、线程中常用的方法
1. isAlive()判断线程是否存活
2. Thread.sleep(1000)静态方法，让当前线程休眠一段时间，处于阻塞状态。
3. Thread.currentThread().getName()得到当前线程的名字。
4. hread.yield();//静态方法，让出一次当前CPU的使用权,若让出之后其他线程抢不到，那还可以抢回来
示例代码：

`public class TestThread {
    public static void main(String[] args) throws InterruptedException {

        MyThread myThread1 = new MyThread("我的线程");
        myThread1.start();

        System.out.println(myThread1.isAlive());//isAlive()判断线程是否存活
        for(int i=0;i<100;i++){
            Thread.sleep(1000);//静态方法，让当前线程休眠一段时间，处于阻塞状态
            System.out.println(Thread.currentThread().getName()+":"+i);
        }

        System.out.println(myThread1.isAlive());
    }

    public static class MyThread extends Thread{

        public MyThread(String name) {
            super(name);
        }

        @Override
        public void run() {
           for(int i=0;i<100;i++){
               try {
                   if(i%10==0){
                       Thread.yield();//静态方法，让出当前CPU的使用权,若让出之后其他线程抢不到，那还可以抢回来
                   }
                   System.out.println(this.getName()+"休息一秒："+i);
                   Thread.sleep(1000);//线程休眠
               } catch (InterruptedException e) {
                   e.printStackTrace();
               }
           }
        }
    }
}`
5. join():
### 4.2、反射
### 4.3、设计模式
### 4.4、NIO、BIO、AIO
### 4.5、JVM
## 5、微服务
### 5.1、SpringCloud
#### 5.1.2、缓存
redis、memarycache
#### 5.1.3、消息中间件
RabbitMQ、activemq、rocketMQ、socketmq等
#### 5.1.4、注册中心
Nacous、Eureka、zookeeper
#### 5.1.5、网关
Gateway、Zuul
#### 5.1.6、断路器
Hystrix、sentinel
#### 5.1.7、负载均衡
Nginx、Ribbon
#### 5.1.8、Bus
#### 5.1.9、Tomcat
#### 5.1.10、Netty
## 6、计算机网络
### 6.1、DNS是什么？
### 6.2、cookie和session异同?
cookie和session都是用来存储用户信息的。
为什么要使用cookie？由于http协议是一种无状态的协议，这会导致客户端和服务端无法相认。
cookie存储在客户端，session存储在服务端。
cookie数据量最大为4K,session的数据量大小没有限制。
## 7、热点面试题
### 7.1、==和equals区别？
答：==比较的是引用的地址，equals比较的是字符串里面的内容，一般情况下，判断字符串是否为空，会选择equals。
### 7.2、String、StringBuffer、StringBuilder的区别？
答：String是不可变对象，线程安全，效率低。
       StringBuffer是可变对象，线程不安全，效率中等。
       StringBuilder也是可变对象，线程不安全，效率最高。
### 7.3、HashMap?
### 7.4、finalize、final、finaly区别？
### 7.5、volital和synchronized区别？
### 7.6、SpringBoot单元测试？
## 8、数据结构和算法
## 9、简历优化