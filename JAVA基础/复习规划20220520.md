# 复习规划
## 1.JAVA基础
### 1.1、JAVA基本数据类型
答：分四类，公8种。
1. 整型：byte(1),short(2),int（4），Long(8);
2. 浮点型：float(4),double(8);
3. 布尔型：boolean：true,false;
4. 字符型：char(2)
### 1.2、Java类和对象的概念
JAVA是面向对象的编程语言，类是对象的抽象表示，对象是类的实例。
#### 1.2.1、类与类之间的关系
关联、聚合、组合、依赖、继承、实现
### 1.3、Java面向对象的三个特征？
封装、继承、多态。
#### 1.3.1、封装
通过访问修饰符public、null、project、private来实现。可以限制性的访问类和对象的方法、属性。
#### 1.3.2、继承
子类可以继承父类所有的东西，但是子类看不到父类private的属性和方法。
#### 1.3.3、多态
将子类的引用赋值给一个父类对象，这样子类可以重写父类的方法，也可以扩展拥有自己的属性和方法。
#### 1.3.4、面向对象编程（OOP）
面向对象编程将现实世界中的概念和事务，以及相应的状态和行为，抽象成计算机语言中的类和对象，以及相应的属性和方法，这是一个抽象的过程。类和对象是面向对象编程的核心概念，它包含有封装、继承、多态三大特征，也有人把抽象作为它的第四大特征。由于面向对象的使用，使得程序的可扩展性大大增强，面向对象编程在大型项目中得到了广泛的使用。面向对象的思想更符合于我们人类对现实世界的认知，可以使我们设计出更加灵活，维护性更好的程序。
### 1.4、抽象方法、抽象类、接口
#### 1.4.1、抽象方法、抽象类
抽象方法、抽象类通过abstract关键字修饰。
含有抽象方法的类必须是抽象类，因为如果某个拥有抽象方法的类被其子类继承，并去掉这个父类的抽象方法，而抽象方法是没有方法体的，这时候应该输出什么呢？
答：编译器肯定会报错，所以这个时候就只能将这个父类也声名为抽象类，这样其子类就必须去重写它的抽象方法，这样就这个问题就解决了。当然如果这个子类不需要重写这个抽象方法，那也可以将自己也定义为抽象类即可。
一个类只能继承一个父类，即单继承。
#### 1.4.2、接口
通过interface关键字修饰。接口里面有常量和抽象方法，就是通过实现该接口的类去重写抽象方法，从而实现多态。
一个类可以实现多个接口。
万事万物皆对象，面向对象编程，面向接口编程。
JDK8以后，接口里面可以有静态方法（static）和默认方法（default）。  
### 1.5、封箱和拆箱
### 1.6、异常处理
#### 1.6.1、 JAVA处理异常的思路：
一是自己捕获处理，即加try(){}catch(){};
二是处理以后再向上抛出；
三是直接向上抛出(throw e)异常,对应的方法上也要加上throws e，甚至可以将异常抛给main方法，最终交由JVM去处理，当然不推荐这样做。
#### 1.6.2、JAVA程序的错误：
1. 代码错误，一般编译器就会帮我们指出。
2. 逻辑错误，需要测试，才能排查出来。
3. 程序运行期发生的错误。这种错误也分三种，一种是error，比如内存溢出等，这种不用出来，JVM会报错，直接终止程序；第二种是运行时异常（RuntimeException），也叫非受检查异常，也不用处理，JVM会处理，打出堆栈错误，终止程序等等；第三种是除前两种意外的异常（空指针等），也叫受检查异常或非运行时异常，需要我们去处理，必须捕获处理，或向上抛出。
4. 自定义异常
#### 1.6.3、therow和throws的区别？
throw用于在方法内部抛出异常，throws用于方法之上，两者一般是成对出现。
### 1.7、IO流
### 1.8、集合
JAVA中的集合又称容器，是对数据结构的一种实现，通过集合，我们可以完成对数据的增删改查，方便程序员管理数据。
JAVA中集合中的数据是存储在内存当中的，是一种临时的数据存储方式，当服务器重启或出现故障的情况下，集合中的数据就会消失。
#### 1.8.1、JAVA集合体系
![JAVA集合体系](vx_images/168244017220562.png =998x)
#### 1.8.2、Collection接口
1. List和Set集合的父接口，当然还有其它的实现类或子接口。
#### 1.8.3、List接口
Collection接口的子接口，存储有序，可重复的数据。
#### 1.8.4、ArrayList
数据结构：数组，相对于链表，查询快，增删慢。
常用方法：

` List<String> arrayList=new ArrayList<>();
        arrayList.add("尾");//尾加
        arrayList.add(1,"一");//插入
        arrayList.add(1,"二");//插入一个新值，原先在这个位置上的将往后移一位
        arrayList.set(1,"3");//覆盖掉原先在这个位置上的值
        arrayList.remove(0);
        arrayList.remove("一");
        //遍历方式：1、for循环、2、增强for、3、迭代器iterator
        Iterator<String> iterator = arrayList.iterator();
        while (iterator.hasNext()){
            System.out.println(iterator.next().toString());
        }`
        
扩容机制：1.5N,生成一个新的数组，将原来的数组复制到新的数组中。删除同理。

`
//默认长度10
private static final int DEFAULT_CAPACITY = 10;
`

不足点：线程不安全，方法无synchronized修饰等。与之对应的Vector是线程安全的。
#### 1.8.5、LinedkList
数据结构：双向非循环链表，相对于数组，增删快，查询慢。
常用方法：

` LinkedList<String> linkedList=new LinkedList<>();
        linkedList.add("一");
        linkedList.add("二");
        linkedList.addLast("tail");
        linkedList.addFirst("head");
        System.out.println(linkedList.toString());//[head, 一, 二, tail]
        linkedList.remove("一");
        System.out.println(linkedList.toString());//[head, 二, tail]`
        
不足点：线程不安全，方法无synchronized修饰等。
#### 1.8.6、Set
Set继承了Collection接口，里面没有额外的方法。
实现无序（这里的无序是指和元素的添加顺序不一致而已，其实里面有排序规则），不可重复的数据集合。
#### 1.8.7、HashSet
数据结构：基于HashMap实现。
特点：存储无序，不可重复的数据。没有根据索引操作数据的方法。
常用方法：

`Set<String> hashSet=new HashSet<>();
        hashSet.add("a");
        hashSet.add("b");
        hashSet.add("c");
        hashSet.add("a");//有重复则覆盖
        hashSet.remove("c");
        for (String s:hashSet
             ) {
            System.out.println(s.toString());
        }`
        
#### 1.8.10、TreeSet
数据结构：基于TreeMap实现。
常用方法：

`  TreeSet<String> treeSet= new TreeSet<>();
       treeSet.add("a");
       treeSet.add("b");
       treeSet.add("c");
       treeSet.add("a");//覆盖掉相同的值
       treeSet.remove("c");
        for (String s:treeSet
             ) {
            System.out.println(s.toString());
        }`
        
#### 1.8.11、Map接口
Map接口是独立的接口，和Collection没关系。
Map中的每一个元素都是一个entry类型，每个元素包含key(键)和value(值)。
Map存储无序（指和添加元素时的顺序不一致），不可重复的元素。
#### 1.8.12、HashMap
HashMap是对散列表的具体实现。
数据结构：数组+链表。

`Map<String,Object> hashMap=new HashMap<>();
        hashMap.put("1","张三");
        hashMap.put("2","张三");
        hashMap.put("3","李四");
        hashMap.put("3","李四四");//key相同则覆盖掉原来的值
        hashMap.put(null,null);//只允许一个key为null
        hashMap.put("4",null);//可允许多个value为null
        //遍历：
        //keySet遍历：
        for (String key:
                hashMap.keySet()) {
            System.out.println(key);
        }
        //entry遍历
        for (Map.Entry<String,Object> entry:
             hashMap.entrySet()) {
            System.out.println("key:"+entry.getKey().toString()+";"+"value:"+entry.getValue());
        }
`

不足：线程不安全。
特点：只允许一个key为null,多个value为null，但遍历取值的时候有可能报空指针异常。
#### 1.8.13、TreeMap
数据结构：红黑树。
特点：和HashMap类似，不允许key为null。
常用方法：

` Map<String,Integer> treeMap=new TreeMap<>();
        treeMap.put("张三",20);
        treeMap.put("李四",30);
        treeMap.put("王麻子",40);
        treeMap.put("王麻子",43);//key重复，则覆盖掉原来的value
        treeMap.put(null,43);//不允许key为null的情况,若为key为空，则会报空指针的错误
        treeMap.remove("李四");
        //遍历 1、keySet()
        for (String key:treeMap.keySet()) {
            System.out.println(key);
        }
        //遍历 2、entrySet() 遍历
        for (Map.Entry<String,Integer> entry:treeMap.entrySet()) {
            System.out.println(entry.getKey()+":"+entry.getValue());
        }
`

#### 1.8.14、Iterator
迭代器，是一个接口，每一个集合的实现类的内部基本都有对Iterator的实现，通过Iterator可以实现对集合的遍历。
存在的意义：隐藏集合内部的实现细节，无论那种集合都是通过Iterator操作，而不是直接操作该集合。
实例化：每个集合都有.iterator()方法，该方法的返回值就是一个迭代器对象。
示例：

` List<String> arrayList=new ArrayList<>();
        arrayList.add("尾");//尾加
        arrayList.add(1,"一");//插入
        arrayList.add(1,"二");//插入一个新值，原先在这个位置上的将往后移一位
        arrayList.set(1,"3");//覆盖掉原先在这个位置上的值
        arrayList.remove(0);
        arrayList.remove("一");
        //遍历方式：1、for循环、2、增强for、3、迭代器iterator
        Iterator<String> iterator = arrayList.iterator();
        while (iterator.hasNext()){
            System.out.println(iterator.next().toString());
            iterator.remove();//删除当前值
        }`
        
#### 1.8.15、Collections
Collections是一个工具类型，一个专门操作集合的工具类
常用方法：

`List<Integer> arrayList=new ArrayList<>();
      arrayList.add(5);
      arrayList.add(3);
      arrayList.add(1);
      arrayList.add(2);
      arrayList.add(4);
      System.out.println(arrayList.toString());//[5, 3, 1, 2, 4]
      Collections.sort(arrayList);//排序
      System.out.println(arrayList.toString());//[1, 2, 3, 4, 5]
       //添加多个值到集合当中
        Collections.addAll(arrayList,7,8,9,67,68,69);
        System.out.println(arrayList.toString());//[1, 2, 3, 4, 5, 7, 8, 9, 67, 68, 69]
        //取最大值，最小值
        Integer max = Collections.max(arrayList);
        System.out.println(max);//69
        Integer min = Collections.min(arrayList);
        System.out.println(min);//1`
        
### 1.9、泛型
### 1.10、枚举

## 2、主流框架
### 2.1、SpringMVC
#### 2.1.1、Aop和IOC(DC)
#### 2.1.2、常用组件
#### 2.1.3、执行流程
#### 2.1.4、拦截器和过滤器的区别
### 2.2、SpringBoot
#### 2.2.1、执行原理
#### 2.2.2、常见注解
@Resource和@Autowired异同
### 2.3、持久层框架
#### 2.3.1、MyBaits
##### 2.3.1.1、执行原理
##### 2.3.1.2、#和$的区别
## 3、数据库
### 3.1、MySQL
#### 3.1.1、三大范式
#### 3.1.2、事务与ACID
#### 3.1.3、索引
1. 索引失效
2. 索引类型
#### 3.1.4、存储引擎
#### 3.1.5、JDBC驱动执行顺序（MyBatis执行原理）
#### 3.1.6、SQL执行顺序
from、on、join、where、group by  having、select、distinct、union、order by
#### 3.1.7、常见聚合函数
### 3.2、Oracle
#### 3.2.1、函数、存储过程、视图
## 4、JAVA高级
### 4.1、多线程
#### 4.1.1、并行与并发
并行：指多个任务同时进行，强调的是各个任务之间的独立性和实时性。计算机中指多个处理器同时执行多个任务。
并发：在一个系统内，当资源有限的情况下，通过并发设计，达到部分并行的效果。计算机中指一个处理器，按一定的设计，尽可能达到同时处理多个任务的效果。
#### 4.1.2、进程与线程
进程：
1. 一个正在进行的程序。一个进程中可以使用多个线程来实现并发设计，从而达到并行的效果。
2. 一个进程有自己的内存资源。
3. 一个进程有自己的生命周期，包括创建、生存、消亡等。
线程：
1. 进程的基本单位。在JAVA程序中，程序从一个主线程（main线程）开始，主线程可以创建其他的线程。
2. 线程也有自己的生命周期。创建、生存、消亡等。
3. 线程是进程的一个组件，一个进程中的多个线程可以共享这个进程的内存等资源。
#### 4.1.3、Java程序、JVM实例、用户线程（User Thread）、守护线程(Daemon Thread)
1. 以JAVA命令启动的JAVA程序，都会新增一个JVM实例。一旦程序结束，JVM实例也就销毁了。每个程序都会获得自己的JVM实例和对应的OS级进程，并且每个JVM实例相互独立。
2. 每个JAVA程序运行在单独JVM实例上，每一个JVM实例对应唯一的一个堆，所以一个JAVA程序中的多个线程也就运行同一个JVM实例之上，因此这些线程之间会共享这块堆内存，鉴于此，多线程在访问堆中数据时需要进行线程同步。
3. 守护线程是为其他的线程提供便利服务的，当用户线程结束时，守护线程也就没有存在的意义了，也会销毁。
4. mian线程就是一个用户线程，GC(垃圾回收器)就是一个守护向线程。GC随主线程从开始到结束。
#### 4.1.4、JAVA中创建线程
`public class Test {
    public static void main(String[] args) throws Exception {
    
        //1、继承Thread类，重写run()方法，在run()方法里面写具体的逻辑。
        //注意用对象调用的时候是调start()方法启动线程，线程启动之后JVM会自动去再掉run()方法。
        //永远不要启动一个线程超过一次，即使这个线程启动完毕，也不要再启动该线程。
        //Thread类里面的run()方法只是一个方法，不能用于启动线程。源码中有标注。
        MyThread myThread=new MyThread();
        myThread.start();
        
        //2、实现Runnable接口，重写run()方法，在run()方法里面写具体的逻辑。还是通过start()方法启动线程。
         Thread runnableThread = new Thread(new MyRunnable());
         runnableThread.start();
         
        //还可以直接写成匿名内部类的方式：
         Thread thread = new Thread(new Runnable() {
            @Override
            public void run() {
                for(int i=0;i<50;i++){
                    System.out.println(Thread.currentThread().getName()+":"+i);
                }

            }
        });
        thread.start();
        
        //3、实现Callable<T>接口，重写call()方法，在call()方法里面写具体的逻辑。
        //特点：有返回值，返回值的类型就是实现该接口时传进去的泛型T。
        FutureTask<String> futureTask=new FutureTask<String>(new MyCallable1());
            Thread thread=new Thread(futureTask);
            thread.start();
            try {
                System.out.println("main线程调用get()");
                if(futureTask.isDone()){
                    String s = futureTask.get();
                    System.out.println(s);
                }else {
                    System.out.println("main:先干其他的事情了");
                    Thread.sleep(2000);
                    String s = futureTask.get();
                    System.out.println(s);
                }
            } catch (InterruptedException |ExecutionException e) {
                e.printStackTrace();
            }
        }
    }
}

class MyThread extends Thread{

    @Override
    public void run() {
        for(int i=0;i<100;i++){
            System.out.println("MyThread："+i);
        }
    }
}

class MyRunnable implements Runnable{

    @Override
    public void run() {
        for(int i=0;i<100;i++){
            System.out.println("MyRunAble："+i);
        }
    }
}

class MyCallable1 implements Callable<String>{

    @Override
    public String call(){
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("线程就绪并已经启动了");
        return "from MyCallable1";
    }
}
`
使用Callable<V>接口创建子线程
1. Runnable接口无返回值，也无法抛出异常，所以就设计了Callable接口
* Callable接口规定的方法是V call(),而Runnable接口的方法是run()。
* V call()方法可抛出异常，而run()方法不能抛出异常。
* V call()方法有返回值，而run()方法无返回值。
* Callable接口配合FutureTask对象一起，创建子线程，执行V call()方法，并取得执行结果。
2. 实现原理
* 实现Callable<V>接口，在其V call()方法里面写需要子线程执行的代码，并将返回值以V类型返回。
* Future接口提供了V get()方法，用于得到返回值。
* FutureTask类实现了RunnableFuture接口，这个接口继承自两个接口：Runnable和Future。在创建FutureTask对象的时候，可以把Callable接口的实现对象传入。这样FutureTask对象因为实现了Runnable接口，可以用于创建子线程，因为有了Callable接口的实现对象的引用，可以调用回调方法V call(),得到返回值V，因为其实现了Future接口，可以通过V get()方法提供返回值给外部。
* 这是一种异步回调V call()方法的方式。
##### 4.1.4.1、线程中常用的方法
1. isAlive()判断线程是否存活
2. Thread.sleep(1000)静态方法，让当前线程休眠一段时间，处于阻塞状态。
3. Thread.currentThread().getName()得到当前线程的名字。
4. hread.yield();//静态方法，让出一次当前CPU的使用权,若让出之后其他线程抢不到，那还可以抢回来
示例代码：

`public class TestThread {
    public static void main(String[] args) throws InterruptedException {

        MyThread myThread1 = new MyThread("我的线程");
        myThread1.start();

        System.out.println(myThread1.isAlive());//isAlive()判断线程是否存活
        for(int i=0;i<100;i++){
            Thread.sleep(1000);//静态方法，让当前线程休眠一段时间，处于阻塞状态
            System.out.println(Thread.currentThread().getName()+":"+i);
        }

        System.out.println(myThread1.isAlive());
    }

    public static class MyThread extends Thread{

        public MyThread(String name) {
            super(name);
        }

        @Override
        public void run() {
           for(int i=0;i<100;i++){
               try {
                   if(i%10==0){
                       Thread.yield();//静态方法，让出当前CPU的使用权,若让出之后其他线程抢不到，那还可以抢回来
                   }
                   System.out.println(this.getName()+"休息一秒："+i);
                   Thread.sleep(1000);//线程休眠
               } catch (InterruptedException e) {
                   e.printStackTrace();
               }
           }
        }
    }
}`
5. join():A线程调用B线程的方法，则A线程阻塞，必须等到B线程执行完以后，A线程才会结束阻塞，继续执行。

`
/**
 * @Description: 启用两个子线程，分别求0-50和51-100的和，并返回给主线程，由主线程求出最终的和
 * @Author: yangyb
 * @Date:2022/5/23 11:58
 * Version: 1.0
 **/
public class TestSum {

    public static void main(String[] args){
        SumThread sumThread = new SumThread(1, 50);
        SumThread sumThread1 = new SumThread(51, 100);

        sumThread.start();
        sumThread1.start();

        try {
            sumThread.join();
            sumThread1.join();
            int sum=sumThread.get()+sumThread1.get();
            System.out.println(sum);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

class SumThread extends Thread {
    int num1,num2,sum;

    public int get(){
        return sum;
    }

    public SumThread(int num1,int num2){
        this.num1=num1;
        this.num2=num2;
    }

    @Override
    public void run() {
        add();
    }

    public void add(){

        for(int i=num1;i<=num2;i++){
            sum+=i;
        }
    }
}`

6. 中断线程：
过时的（deprecated）方法：stop()、suspend()、destroy()、resume()，避免使用，比如stop()方法，使得调用者可以立即终止一个线程，而这个线程可能在进行某些不适合立刻中断的操作，否则会引起比如，被迫释放锁，引起数据不一致，文件，数据库等资源未能关闭等。
interrupt():
A线程调用B线程的此方法，通知B线程，要中断B线程，B线程在自己的run方法里面，通过isInterrupt()或Interrupted()获知此信息，自行决断做何操作。
B线程并不会中断，这个方法只会给线程设置一个为true的中断标志，一旦线程正在调用wait(),join(),sleep()方法中的一种，会立刻抛出一个InterruptedException,B线程可以在catch块中进行进一步处理。
`public class TestInterrupt {

    public static void main(String[] args){

        MyInterruptThread myInterruptThread = new MyInterruptThread();
        myInterruptThread.start();

        try {
            Thread.sleep(1000);
            System.out.println(Thread.currentThread().getName()+"沉睡了一秒钟");
            System.out.println(Thread.currentThread().getName()+"通知子线程中断");
            myInterruptThread.interrupt();//中断子线程
            System.out.println(Thread.currentThread().getName()+"子线程中断完毕");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        myInterruptThread.interrupt();
       }
}

class MyInterruptThread extends Thread{

    @Override
    public void run() {
        try {
            System.out.println("子线程分配资源");
            sleep(5000);
            System.out.println(Thread.currentThread().getName()+"沉睡了五秒钟");
        } catch (InterruptedException e) {
            System.out.println("子线程释放资源");
        }
    }
}
`
#### 4.1.5、线程的优先级
1. JAVA线程中的优先级有1到10共10个等级，等级数越大，优先级越高。有三个常量的等级值：MIN_PRIORITY = 1;NORM_PRIORITY = 5（默认）;MAX_PRIORITY = 10;
2. 可以通过getPriority()方法，得到该值；可以通过setPriority()设置该值。
3. 优先级的设置应该在启动该线程，即调用start()方法之前被设置。
4. 使用CPU资源的时候：同优先级，排队服务，先到先得；在资源有限的情况下，优先级的作用才能体现出来；优先级更多的是给操作系统调度器一个“hint”,至于如何处理，那要看操作系统的调度器实现；线程的高优先级不可以作为线程被优先执行的保证，不要依赖于优先级来写程序；一般对于所有线程使用默认优先级即可。
#### 4.1.6、线程的同步机制
##### 4.1.6.1、举例
创建一个Cat类，包含一个属性age,一个增加年龄的方法addAge(),一个减少年龄的方法minusAge();

`public class Cat {

    int age;
    
    void addAge(){
        System.out.println(Thread.currentThread().getName()+":"+age);
        age++;
        System.out.println(Thread.currentThread().getName()+":"+age);
    }

    void minusAge(){
        System.out.println(Thread.currentThread().getName()+":"+age);
        age--;
        System.out.println(Thread.currentThread().getName()+":"+age);
    }
    
}
`
创建一个测试类，里面创建两个线程，一个用来增加年龄，一个用来减少年龄，看是否能按照我们所想的输出：0110。

`public class Test {

    public static void main(String[] args){

        Cat cat=new Cat();
        //通过Runnable接口创建两个线程
        Thread thread=new Thread(new Runnable(){
            @Override
            public void run(){
                cat.addAge();
            }
        });

        Thread thread1=new Thread(new Runnable(){

            @Override
            public void run(){
                cat.minusAge();
            }
        });

        //一定要记得启动线程
        thread.start();
        thread1.start();
    }
}`
显然，通过运行程序我们发现与我们预期的结果不一样，发生了数据不一致的问题。
##### 4.1.6.1、解决方案
对于同一资源，有多个线程同时访问，导致出现数据不一致的问题，如果我们的程序出现了这种安全隐患问题，就需要进行限制，让同一资源在同一个时间只能被一个线程访问，这种线程访问的安全机制就是“线程同步机制”。
同步指的是让一个个线程排队执行，同指“协同”。
只要在多线程共同访问的方法前面加上synchronized(同步修饰符)，或者把共同运行的代码使用同步代码块synchronized(同步锁提供对象){}括起来，就可以实现同步访问。

1.synchronized(同步修饰符)
`public class Cat {

    int age;
    
    public synchronized void addAge(){
        System.out.println(Thread.currentThread().getName()+":"+age);
        age++;
        System.out.println(Thread.currentThread().getName()+":"+age);
    }

    public synchronized void minusAge(){
        System.out.println(Thread.currentThread().getName()+":"+age);
        age--;
        System.out.println(Thread.currentThread().getName()+":"+age);
    }
}`

2.同步代码块synchronized(同步锁提供对象){}
`public class Test {

    public static void main(String[] args){

        Cat cat=new Cat();
        //通过Runnable接口创建两个线程
        Thread thread=new Thread(new Runnable(){
            @Override
            public void run(){
                synchronized(cat){
                    cat.addAge();
                }
            }
        });

        Thread thread1=new Thread(new Runnable(){

            @Override
            public void run(){
                synchronized(cat){
                    cat.minusAge();
                }
            }
        });

        //一定要记得启动线程
        thread.start();
        thread1.start();
    }
}`

#### 4.1.7、同步锁
1. JAVA中的每个对象都有一把锁，称为固有锁，监视器，同步锁，同步监视器，一般简称锁。
2. 如果一个线程想要独占的执行某个方法，或者某段代码，就需要获得一把锁，把这个方法，或者这段代码锁住，这段时间只允许自己访问。
3. 进入对象的非静态同步方法（synchronized）,默认会使用这个对象this的锁。如果是第一个进去，将自动获得这个锁，但是如果别的线程已经获得，那只能排队等待（同步阻塞）。注意，一个对象上的多个方法，如果都是synchronized修饰，那么他们共用这把锁，因为一个对象只有一个锁。
4. 关键字synchronized也可以用于声名类的静态方法，这时候提供锁的对象是类本身的对象，即类名.class。
5. 锁并不能阻止对象的非同步方法被多线程访问。
6. 进入同步块，则需要借某个对象的锁。如果几个线程想要使用同步一个或者几个代码块，那么他们要使用同一个对象的锁，至于这个对象是什么，并不重要。一般可以使用一个都可以访问到的对象，也可以创造一个Objected类型的对象，甚至可以用某个类的本身即类名.class，这也是一个对象。在用this作为同步锁对象的时候，要注意这个或者这些同步代码块的this是不是同一个对象。
7. synchronized代码块包含住操作共享资源的部分就可以，不要包含过多代码，否则会影响效率，或者影响其他线程使用被包住的非共享资源部分的代码。
8. synchronized方法只能同步方法的本身，即一个线程执行此方法的时候，其他线程不能执行此方法，并且不能执行此对象上的任何synchronized方法，因为这些方法用的是对象本身这同一把锁。但如果一个线程需要调用这个对象的几个synchronized方法完成一个复合的同步操作，这个中间会有间隔，就会释放锁，那么需要使用同步代码块来将几个方法一起锁住（同步）。
9. 因为同步方法在多线程同时访问的时候需要等待，同步方法的执行效率低于非同步方法。 
##### 4.1.7.1、Lock同步锁
1. 同步方法、同步代码块都是通过同步关键字synchronized来实现的,JDK5以后，提供了一种方式来实现同步访问，即Lock,在java.util.concurrent.locks里面。
2. Lock是接口，而synchronized是关键字，是通过内置语言来实现的。
3. ReentrantLock是Lock接口的实现类，是可重入锁，即如果已经有一个对象锁，那么当它调用同一对象的其他同步方法的时候，就不需要再次申请这个对象的锁。
4. ReentrantLock和synchronized都是可重入锁。
5. lock(),手动加锁
6. ReentrantLock(true)传入true,表示等待锁的线程，按先到先得的顺序公平使用锁，那就是公平锁；不传该参数，这个参数默认为false，就是非公平锁，所以ReenTrantLock默认就是非公平锁，无法保证等待的线程获取锁的顺序。
7. tryLock(1, TimeUnit.MILLISECONDS),尝试拿到锁，若成功则返回true,失败，会等待一段时间，再次尝试拿锁。
8. tryLock()尝试拿到锁，若成功则返回true,失败，返回false.
9. unlock(),手动解锁。若忘记释放锁，则有可能造成死锁，即使发生异常也要释放锁，为了避免这种情况的发生，一般写在finally块中解锁。
示例代码：

`public class Testlock {

    public static void main(String[] args){

        Cat cat = new Cat();

        Lock lock=new ReentrantLock();//创建一个可重入锁
        new Thread(new Runnable(){

            @Override
            public void run() {
                try {
                    if (lock.tryLock(1, TimeUnit.MILLISECONDS)) {
                        try {
                            lock.lock();//加锁
                            System.out.println(Thread.currentThread().getName() + ":" + cat.getAge());
                            cat.addAge();
                            System.out.println(Thread.currentThread().getName() + ":" + cat.getAge());
                        } finally {
                            lock.unlock();//释放锁
                        }
                    }
                } catch (InterruptedException e) {
                    System.out.println(Thread.currentThread().getName() + "没有拿到锁");
                }
            }
        }).start();

        new Thread(new Runnable(){

            @Override
            public void run(){
                try {
                    if (lock.tryLock(1, TimeUnit.MILLISECONDS)) {
                        try {
                            lock.lock();//加锁
                            System.out.println(Thread.currentThread().getName() + ":" + cat.getAge());
                            cat.minusAge();
                            System.out.println(Thread.currentThread().getName() + ":" + cat.getAge());
                        }finally{
                            lock.unlock();//释放锁
                        }
                    }
                } catch (InterruptedException e) {
                    System.out.println(Thread.currentThread().getName() + "没有拿到锁");
                }
            }
        }).start();
    }
}
`
`public class Cat {

        int age;
        void addAge(){
            age++;
        }

    void minusAge(){
        age--;
    }

    public int getAge(){
        return age;
    }
}`

##### 4.1.7.2、死锁
两个或多个线程，在各自使用一把锁的时候，为了完成当前的执行，需要使用对方正在使用的锁，这样一来，双方都在等待对方释放手中的锁，就造成循环等待，发生了死锁。死锁发生后，并不会发生异常，难以调试。
`public class DeadLock {

    public static void main(String[] args){

        Object o1=new Object();
        Object o2=new Object();

        new Thread(new Runnable(){

            @Override
            public void run(){
                synchronized(o1){
                    try {
                        Thread.sleep(1000);
                    }catch (InterruptedException e){
                        e.printStackTrace();
                    }
                    System.out.println(Thread.currentThread().getName()+"等待o2的锁");

                    synchronized(o2){
                        System.out.println(Thread.currentThread().getName()+"执行了代码");
                    }
                }
            }
        }).start();

        new Thread(new Runnable(){

            @Override
            public void run(){
                synchronized(o2){
                    try {
                        Thread.sleep(1000);
                    }catch (InterruptedException e){
                        e.printStackTrace();
                    }
                    System.out.println(Thread.currentThread().getName()+"等待o1的锁");

                    synchronized(o1){
                        System.out.println(Thread.currentThread().getName()+"执行了代码");
                    }
                }
            }
        }).start();
    }
}`
避免死锁：
1. 嵌套锁，即已经锁住了 一个资源，同时再锁住另一个资源。在多线程的情况下，完全避免一个线程使用多个锁来完成任务，并不现实。所以理清锁的顺序，避免交互加嵌套锁造成死锁。
2. 可以通过Lock回避死锁。比如使用tryLock()回避死锁问题。 
#### 4.1.8、wait-notify机制
1. 每个对象从Object类继承下来，就拥有了一把锁（监视器），wait(),notify(),notifyAll()方法，一个锁池，一个等待池。
2. 线程可以在synchronized的同步方法，和同步块里面使用一个对象锁来锁定资源，也可以调用对象的这几个方法实现wait和notify。
3. 注意，对象的wait(),notify(),notifyAll()方法只能在对象自己锁定的同步代码块或者同步方法中被调用。
4. 如果一个线程想要获取锁，若果锁已经被占用了，则此线程进入锁池，称为阻塞(blocked)。
5. 如果线程t已经拥有锁，在需要某些条件，暂时不执行了，则可以调用锁对象.wait()，释放锁，进入等待池，等待条件满足了，别的线程调用锁对象.notify()后，线程t从等待池再次进入锁池，等到线程t竞争到锁后，再从wait()方法处向后执行。
6. 也可以调用锁对象.wait(时间)，如果没有等到notify，等待的时间到，则进入锁池。
7. 锁对象.notify()，从等待池中随机选一个线程，放入锁池。
8. 锁对象.notifyAll()，将所有等待池中的线程，放入锁池。
9. 两个或者多个线程，可以使用同一把锁的wait(),和notify()方法相互协作，实现线程间的通讯。

`public class WaitNotify {

    public static void main(String[] args){

        Object o = new Object();

        new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (o) {
                    System.out.println("2、子线程通知主线程，主线程满足条件，可以进入该对象的锁池！");
                    o.notify();
                }
                System.out.println("3、子线程释放锁！");
            }
        }).start();

        synchronized (o){
            try {
                System.out.println("1、主线程不满足条件，进入该对象的等待池！");
                o.wait();
                System.out.println("4、主线程满足，从等待池释放进入该对象的锁池！，并且拿到了锁，继续执行");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}`
#### 4.1.9、park和unpark

1. park()和unpark()不是线程的方法，也不是锁对象的方法，而是LockSupport类中的两个静态方法，这个类位于java.util.concurrent.locks包中。
2. 用法：
* 在线程t1中调用LockSupport.park()，用于暂停当前线程t1的运行。
* 在另外的线程调用LockSupport.unpark(t1)，恢复线程t1的运行。
* 比如：t1先park,过段时间t2中再unpark(t1),t1继续从park处执行；或者t2先提前unpark(t1),过段时间t1再park,t1会继续执行，注意，unpark不能累加。这两种顺序，代码都可以执行。
* 注意，park和unpark虽然也可以实现线程间通讯，但是与wait-notify不同，不需要在synchronized同步代码块中进行。
* 也可以执行park的时间，如果时间到了，没有等到unpark，也会恢复线程运行。parkNanos(纳秒)，1纳秒=十亿分之一秒；parkUntil(截止时间)，截止时间为从Epoch(1970年1月1午夜)开始的毫秒数。

`public class ParkAndUnpark {

    public static void main(String[] args){

        Thread t1 = new Thread(new Runnable() {

            @Override
            public void run() {
                System.out.println(Thread.currentThread().getName()+":t1开始执行");
                park();
                System.out.println(Thread.currentThread().getName()+":t1执行结束");
            }
        });

        Thread t2 = new Thread(new Runnable() {

            @Override
            public void run() {
                System.out.println(Thread.currentThread().getName()+":t2开始执行");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                unpark(t1);
                System.out.println(Thread.currentThread().getName()+":t2执行结束");
            }
        });

        t1.start();
        t2.start();
    }
}`
#### 4.1.10、比较sleep和wait
1. 两个方法都是使用当前线程释放CPU，进入睡眠或等待。
2. sleep()是线程的静态方法，通过Thread.sleep()来调用；而wait()是锁对象的方法。
3. sleep()不强制要求和synchronized配合使用，而wait()方法需要和synchronized一起使用。
4. 使用Thread.sleep()使得当前线程进入睡眠，当前线程如果持有锁，并不会释放锁；而锁对象.wait()使得当前线程进入当前锁对象的等待池，会释放锁。
#### 4.1.11、比较park-unpark和wait-notify
1. 两者都可以实现线程间通讯。
2. wait-notify是属于锁对象的，需要在锁的synchronized同步代码中被锁对象调用；park和unpark与synchronized同步代码无关，是属于LockSupport的静态方法，直接就可以执行。
3. unpark可以具体唤醒某个线程，而notify只能随机唤醒一个等待的线程，notifyALL是唤醒所有等待线程。
4. park和unpark可以先unpark,这个unpark依然可以对后面的park起作用；而wait-notify如果先notify，则不会对后面的wait起作用。
#### 4.1.12、回调（Callback）
1. 回调方法是指一个方法当一个事件发生的时候被调用，通常可以使用接口来定义回调方法，再把一个接口的实现传递到负责触发这个事件的系统中去。
2. 简单的说:回调是指把一段代码，传递给另外一段代码，让第二段代码来执行第一段代码。
#### 4.1.13、同步调用和异步调用
1. 同步调用是基本的调用方式，调用者要等待（被阻塞）被调用者返回，才会继续执行。一般的方法调用，就是同步调用。比如：线程t1中调用类B的方法b()，一直等待b()方法执行完毕，t1才继续往下走。
2. 异步调用，调用者不需要等待（非阻塞）被调用者返回，调用者在调用被调用者后，会立即继续执行。比如：线程t1通过新启动线程的方式调用另外的代码，t1的代码会接着往下执行。
3. 这两种调用方式的最大区别，就是同步调用需要等待被调用者返回，而异步调用不需要等待。使用多线程的异步调用方式，可以在被调用线程执行号是任务的时候，调用线程可以继续执行代码，这是一种非阻塞的处理。
#### 4.1.14、线程池
1. 对于大量使用线程，并且线程执行时间比较短，就会需要频繁创建和销毁线程，线程的创建和销毁比较耗费计算机资源，也提高了软件编写中对于线程调度的要求。
2. 使用线程池，可以维护多个线程供直接使用，复用，并可以获得线程池提供的对于线程的管理和调度。
* 节约资源：线程创建和销毁造成比较耗费资源，重复使用现成的线程可以节约资源。
* 提高响应：可以立刻拿现成的线程使用，不需要等待线程创建。
* 可管理性：可以对线程进行统一的分配，管理，和优化。
3. 线程池原理
* 线程池里面使用了一个生产者-消费者模型：任务管理和线程管理。
* 用户将任务，即业务逻辑写在Runnable接口实现类或者Callable接口实现类里面，然后提交给线程池。
* 线程池会给任务分配线程，让线程运行任务。
4. 线程池的创建
 * 使用Executors工具类来创建线程池对象ThreadPoolExecutor，以ExecutorService接口返回。
 * 通过ExecutorService接口来执行任务。
 * 使用完线程池，使用ExcutorService要关闭shuntdown()。
 * 可以通过ThreadPoolExecutor可以设置线程池配置参数，一般不需要设置，Executors创建线程池的时候已经默认设置。
 
`public class PoolTest {

    public static void main(String[] args){

        ExecutorService executorService=Executors.newFixedThreadPool(10);
        executorService.execute(new MyRun());
        executorService.shutdown();

    }
}

class MyRun implements Runnable{

    @Override
    public void run(){

        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName()+":执行了任务！");
    }
}
`
#### 4.1.15、线程的生命周期
1. Thread.State
* NEW(新建)：还没有调用start();
* RUNNABLE(可运行的)：可以运行的状态，进一步分为就绪(READY，等待CPU使用权)与运行(RUNNING,正在运行)。
* BLOCKED(阻塞)：现在在等待监视器锁，即synchronized设定的对象内置锁。
* WAITING（等待）：线程无期限等待，等待其他线程执行一个特定动作。
* TIMED_WAITING(限时等待)：线程等待其他线程执行一个特定动作，最多等待设定的时间。
* TERMINATED(终止)：线程生命周期结束。
### 4.2、反射
### 4.3、设计模式
#### 4.3.1、单例

### 4.4、NIO、BIO、AIO
### 4.5、JVM
## 5、微服务
### 5.1、SpringCloud
#### 5.1.2、缓存
redis、memarycache
#### 5.1.3、消息中间件
RabbitMQ、activemq、rocketMQ、socketmq等
#### 5.1.4、注册中心
Nacous、Eureka、zookeeper
#### 5.1.5、网关
Gateway、Zuul
#### 5.1.6、断路器
Hystrix、sentinel
#### 5.1.7、负载均衡
Nginx、Ribbon
#### 5.1.8、Bus
#### 5.1.9、Tomcat
#### 5.1.10、Netty
## 6、计算机网络
### 6.1、DNS是什么？
### 6.2、cookie和session异同?
cookie和session都是用来存储用户信息的。
为什么要使用cookie？由于http协议是一种无状态的协议，这会导致客户端和服务端无法相认。
cookie存储在客户端，session存储在服务端。
cookie数据量最大为4K,session的数据量大小没有限制。
## 7、数据结构和算法
## 8、简历优化