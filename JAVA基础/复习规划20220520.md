# 复习规划
## 1.JAVA基础
### 1.1、JAVA基本数据类型
答：分四类，公8种。
1. 整型：byte(1),short(2),int（4），Long(8);
2. 浮点型：float(4),double(8);
3. 布尔型：boolean：true,false;
4. 字符型：char(2)
### 1.2、Java类和对象的概念
JAVA是面向对象的编程语言，类是对象的抽象表示，对象是类的实例。
#### 1.2.1、类与类之间的关系
关联、聚合、组合、依赖、继承、实现
### 1.3、Java面向对象的三个特征？
封装、继承、多态。
#### 1.3.1、封装
通过访问修饰符public、null、project、private来实现。可以限制性的访问类和对象的方法、属性。
#### 1.3.2、继承
子类可以继承父类所有的东西，但是子类看不到父类private的属性和方法。
#### 1.3.3、多态
将子类的引用赋值给一个父类对象，这样子类可以重写父类的方法，也可以扩展拥有自己的属性和方法。
### 1.4、抽象方法、抽象类、接口
#### 1.4.1、抽象方法、抽象类
抽象方法、抽象类通过abstract关键字修饰。
含有抽象方法的类必须是抽象类，因为如果某个拥有抽象方法的类被其子类继承，并去掉这个父类的抽象方法，而抽象方法是没有方法体的，这时候应该输出什么呢？
答：编译器肯定会报错，所以这个时候就只能将这个父类也声名为抽象类，这样其子类就必须去重写它的抽象方法，这样就这个问题就解决了。当然如果这个子类不需要重写这个抽象方法，那也可以将自己也定义为抽象类即可。
一个类只能继承一个父类，即单继承。
#### 1.4.2、接口
通过interface关键字修饰。接口里面有常量和抽象方法，就是通过实现该接口的类去重写抽象方法，从而实现多态。
一个类可以实现多个接口。
万事万物皆对象，面向对象编程，面向接口编程。
JDK8以后，接口里面可以有静态方法（static）和默认方法（default）。  
### 1.5、封箱和拆箱
### 1.6、异常处理
#### 1.6.1、 JAVA处理异常的思路：
一是自己捕获处理，即加try(){}catch(){};
二是处理以后再向上抛出；
三是直接向上抛出(throw e)异常,对应的方法上也要加上throws e，甚至可以将异常抛给main方法，最终交由JVM去处理，当然不推荐这样做。
#### 1.6.2、JAVA程序的错误：
1. 代码错误，一般编译器就会帮我们指出。
2. 逻辑错误，需要测试，才能排查出来。
3. 程序运行期发生的错误。这种错误也分三种，一种是error，比如内存溢出等，这种不用出来，JVM会报错，直接终止程序；第二种是运行时异常（RuntimeException），也叫非受检查异常，也不用处理，JVM会处理，打出堆栈错误，终止程序等等；第三种是除前两种意外的异常（空指针等），也叫受检查异常或非运行时异常，需要我们去处理，必须捕获处理，或向上抛出。
4. 自定义异常
#### 1.6.3、therow和throws的区别？
throw用于在方法内部抛出异常，throws用于方法之上，两者一般是成对出现。
### 1.7、IO流
### 1.8、集合
JAVA中的集合又称容器，是对数据结构的一种实现，通过集合，我们可以完成对数据的增删改查，方便程序员管理数据。
JAVA中集合中的数据是存储在内存当中的，是一种临时的数据存储方式，当服务器重启或出现故障的情况下，集合中的数据就会消失。
#### 1.8.1、JAVA集合体系
![JAVA集合体系](vx_images/168244017220562.png =998x)
#### 1.8.2、Collection接口
1. List和Set集合的父接口，当然还有其它的实现类或子接口。
#### 1.8.3、List接口
Collection接口的子接口，存储有序，可重复的数据。
#### 1.8.4、ArrayList
数据结构：数组，相对于链表，查询快，增删慢。
常用方法：
` List<String> arrayList=new ArrayList<>();
        arrayList.add("尾");//尾加
        arrayList.add(1,"一");//插入
        arrayList.add(1,"二");//插入一个新值，原先在这个位置上的将往后移一位
        arrayList.set(1,"3");//覆盖掉原先在这个位置上的值
        arrayList.remove(0);
        arrayList.remove("一");
        //遍历方式：1、for循环、2、增强for、3、迭代器iterator
        Iterator<String> iterator = arrayList.iterator();
        while (iterator.hasNext()){
            System.out.println(iterator.next().toString());
        }`
扩容机制：1.5N,生成一个新的数组，将原来的数组复制到新的数组中。删除同理。
`
//默认长度10
private static final int DEFAULT_CAPACITY = 10;
`
不足点：线程不安全，方法无synchronized修饰等。与之对应的Vector是线程安全的。
#### 1.8.5、LinedkList
数据结构：双向非循环链表，相对于数组，增删快，查询慢。
常用方法：
` LinkedList<String> linkedList=new LinkedList<>();
        linkedList.add("一");
        linkedList.add("二");
        linkedList.addLast("tail");
        linkedList.addFirst("head");
        System.out.println(linkedList.toString());//[head, 一, 二, tail]
        linkedList.remove("一");
        System.out.println(linkedList.toString());//[head, 二, tail]`
不足点：线程不安全，方法无synchronized修饰等。
#### 1.8.6、Set
Set继承了Collection接口，里面没有额外的方法。
实现无序（这里的无序是指和元素的添加顺序不一致而已，其实里面有排序规则），不可重复的数据集合。
#### 1.8.7、HashSet
数据结构：基于HashMap实现。
特点：存储无序，不可重复的数据。没有根据索引操作数据的方法。
常用方法：
`Set<String> hashSet=new HashSet<>();
        hashSet.add("a");
        hashSet.add("b");
        hashSet.add("c");
        hashSet.add("a");//有重复则覆盖
        hashSet.remove("c");
        for (String s:hashSet
             ) {
            System.out.println(s.toString());
        }`
#### 1.8.10、TreeSet
数据结构：基于TreeMap实现。
常用方法：
`  TreeSet<String> treeSet= new TreeSet<>();
       treeSet.add("a");
       treeSet.add("b");
       treeSet.add("c");
       treeSet.add("a");//覆盖掉相同的值
       treeSet.remove("c");
        for (String s:treeSet
             ) {
            System.out.println(s.toString());
        }`
#### 1.8.11、Map接口
Map接口是独立的接口，和Collection没关系。
Map中的每一个元素都是一个entry类型，每个元素包含key(键)和value(值)。
Map存储无序（指和添加元素时的顺序不一致），不可重复的元素。
#### 1.8.12、HashMap
HashMap是对散列表的具体实现。
数据结构：数组+链表。
`Map<String,Object> hashMap=new HashMap<>();
        hashMap.put("1","张三");
        hashMap.put("2","张三");
        hashMap.put("3","李四");
        hashMap.put("3","李四四");//key相同则覆盖掉原来的值
        hashMap.put(null,null);//只允许一个key为null
        hashMap.put("4",null);//可允许多个value为null
        //遍历：
        //keySet遍历：
        for (String key:
                hashMap.keySet()) {
            System.out.println(key);
        }
        //entry遍历
        for (Map.Entry<String,Object> entry:
             hashMap.entrySet()) {
            System.out.println("key:"+entry.getKey().toString()+";"+"value:"+entry.getValue());
        }
`
不足：线程不安全。
特点：只允许一个key为null,多个value为null，但遍历取值的时候有可能报空指针异常。
#### 1.8.13、TreeMap
数据结构：红黑树。
特点：和HashMap类似，不允许key为null。
## 2、主流框架
### 2.1、SpringMVC
#### 2.1.1、Aop和IOC(DC)
#### 2.1.2、常用组件
#### 2.1.3、执行流程
#### 2.1.4、拦截器和过滤器的区别
### 2.2、SpringBoot
#### 2.2.1、执行原理
#### 2.2.2、常见注解
@Resource和@Autowired异同
### 2.3、持久层框架
#### 2.3.1、MyBaits
##### 2.3.1.1、执行原理
##### 2.3.1.2、#和$的区别
## 3、数据库
### 3.1、MySQL
#### 3.1.1、三大范式
#### 3.1.2、事务与ACID
#### 3.1.3、索引
1. 索引失效
2. 索引类型
#### 3.1.4、存储引擎
#### 3.1.5、JDBC驱动执行顺序（MyBatis执行原理）
#### 3.1.6、SQL执行顺序
from、on、join、where、group by  having、select、distinct、union、order by
#### 3.1.7、常见聚合函数
### 3.2、Oracle
#### 3.2.1、函数、存储过程、视图
## 4、JAVA高级
### 4.1、多线程
#### 4.1.1、并行与并发
并行：指多个任务同时进行，强调的是各个任务之间的独立性和实时性。计算机中指多个处理器同时执行多个任务。
并发：在一个系统内，当资源有限的情况下，通过并发设计，达到部分并行的效果。计算机中指一个处理器，按一定的设计，尽可能达到同时处理多个任务的效果。
#### 4.1.2、进程与线程
进程：一个正在进行的程序。
线程：进程的基本单位。
一个进程可以有若干个线程。
### 4.2、NIO、BIO、AIO
### 4.3、反射
### 4.4、单点登录
### 4.5、设计模式
## 5、微服务
### 5.1、SpringCloud
#### 5.1.2、缓存
redis、memarycache
#### 5.1.3、消息中间件
RabbitMQ、activemq、rocketMQ、socketmq等
#### 5.1.4、注册中心
Nacous、Eureka、zookeeper
#### 5.1.5、网关
Gateway、Zuul
#### 5.1.6、断路器
Hystrix、sentinel
#### 5.1.7、负载均衡
Nginx、Ribbon
#### 5.1.8、Bus
## 5、数据结构和算法
## 6、计算机网络
### 6.1、DNS是什么？
### 6.2、cookie和session异同?
cookie和session都是用来存储用户信息的。
为什么要使用cookie？由于http协议是一种无状态的协议，这会导致客户端和服务端无法相认。
cookie存储在客户端，session存储在服务端。
cookie数据量最大为4K,session的数据量大小没有限制。
## 7、热点面试题
### 7.1、==和equals区别？
答：==比较的是引用的地址，equals比较的是字符串里面的内容，一般情况下，判断字符串是否为空，会选择equals。
### 7.2、String、StringBuffer、StringBuilder的区别？
答：String是不可变对象，线程安全，效率低。
       StringBuffer是可变对象，线程不安全，效率中等。
       StringBuilder也是可变对象，线程不安全，效率最高。
### 7.3、HashMap?
### 7.4、finalize、final、finaly区别？
### 7.5、volital和synchronized区别？
### 7.6、SpringBoot单元测试？
## 8、简历优化