# 数据库
## 3、数据库
### 3.1、MySQL
#### 3.1.1、三大范式
第一范式：每个列都不可以再拆分。
第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。
第三范式：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。
#### 3.1.2、ACID
1. 原子性(Atomicity):一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割。
2. 一致性（Consistency）:在事务开始之前和事务结束之后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。
3. 隔离性（lsolation）:数据库允许多个并发事务同时对数据进行读写和修改，隔离性可以防止多个事务并发执行时由于交叉执行而导致的数据不一致问题。
4. 持久性：事务处理结束后，对数据的修改就是永久的，即使系统故障也不会丢失。
#### 3.1.3、索引
1. 索引失效
2. 索引类型
#### 3.1.4、存储引擎
#### 3.1.5、JDBC驱动执行顺序（MyBatis执行原理）
#### 3.1.6、SQL执行顺序
from、on、join、where、group by  having、select、distinct、union、order by
#### 3.1.7、常见聚合函数
### 3.2、Oracle
#### 3.2.1、函数、存储过程、视图
数据库三大范式是什么？
第一范式：每个列都不可以在拆分。
第二范式：在第一范式的基础上，非主键列完全依赖于逐渐，而不能是依赖于主键的一部分。
第三范式：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。
在设计数据库结构的时候，要尽量遵守三范式，如果不遵守，必须有足够的理由。比如性能。事实上我们经常会为了性能而妥协数据库的设计。、

## #和$区别
1， #是一个占位符，$是拼接符。

  #是一个占位符，$是拼接符。

（1）使用#parameterName方式引用参数的时候，Mybatis会把传入的参数当成是一个字符串，自动添加双引号。

（2）使用$parameterName引用参数时，不做任何处理，直接将值拼接在sql语句中。

2，使用 # 能够防止sql注入，$不能避免注入攻击。
#的方式引用参数，mybatis会先对sql语句进行预编译，然后再引用值，能够有效防止sql注入，提高安全性。$的方式引用参数，sql语句不进行预编译。
3 ，总结：建议使用# 。

## 索引失效
索引失效：模型数空运最快
模  模糊查询 like “%**”
型  数据类型不一致
数  对索引字段使用内部函数
空 索引列有空值
运 索引列进行四则运算
最 最左原则复合索引不按索引最左开始查找
快 全表查询速度比索引快

7. 什么是脏读？幻读？不可重复读？
脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据， 由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。

不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致， 这可能是两次查询过程中间插入了一个事务更新的原有的数据。

幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致， 例如有一个事务查询了几列(Row)数据， 而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中， 就会发现有几列数据是它先前所没有的。
## Mybatis一级缓存和二级缓存
一级缓存：它指的是Mybatis中sqlSession对象的缓存，当我们执行查询以后，查询的结果会同时存入到SqlSession为我们提供的一块区域中，该区域的结构是一个Map，当我们再次查询同样的数据，mybatis会
先去sqlsession中查询是否有，的话直接拿出来用，当SqlSession对象消失时，mybatis的一级缓存也就消失了，同时一级缓存是SqlSession范围的缓存，当调用SqlSession的修改、添加、删除、commit(),close等
方法时，就会清空一级缓存。
二级缓存：他值得是Mybatis中SqlSessionFactory对象的缓存，由同一个SqlSessionFactory对象创建的SqlSession共享其缓存，但是其中缓存的是数据而不是对象，所以从二级缓存再次查询出得结果的对象与
第一次存入的对象是不一样的。
### 4.3、程序优化
#### 4.3.1、架构（程序本身）
1. 将大型单体项目拆分成微服务
2. 采用集群部署
3. JVM性能调优、GC调优、日志优化
4. 池化策略
5. 分库分表，读写分离
#### 4.3.2、提高数据库的读写性能
##### 4.3.2.1、单机数据库
###### 1、查询优化
1. 主键查询千万条记录1-10ms
2. 唯一索引 千万条记录 10-100ms
3. 非唯一索引 千万条记录 100-1000ms
4. 无索引 百万条记录 1000ms+
###### 2、批量写优化
1. for each{insert into table values(1)}
2. Execute once insert table values(1),(2),(3),(4)....
3. Sql编译N次和1次的时间与空间复杂度
4. 网络消耗的时间复杂度
5. 磁盘寻址的复杂度
###### 3、索引优化
###### 4、innodb相关优化
![](vx_images/275823801221022.png =423x)
###### 5、读写分离
一主多存
读库延迟问题处理
主从切换处理
###### 6、分库分表
垂直拆分 
水平拆分
多主多从 
5. MySQL分库分表的目的是？
分库分表就是为了 解决由于数据量过大而导致数据库性能降低的问题， 将原来独立的数据库拆分成若干数据库组成，将数据大表拆分成若干数据表组成， 使得单一数据库、单一数据表的数据量变小，从而达到提升数据库性能的目的。
